/// Request Context
///
/// Context is the most important struct in navi-web. It provides a unified interface
/// for accessing request data and building responses. Context is passed to every
/// handler and middleware.
///
/// # Example
/// ```nv
/// fn handler(ctx: Context) {
///     let id = ctx.param("id") || "0";
///     let page = ctx.query("page") || "1";
///     try? ctx.json({"id": id, "page": page});
/// }
/// ```

use std.fs;
use std.json;
// Note: request, response, worker_context are in same module

/// Handler function type
/// All handlers and middleware use this signature
pub type HandlerFunc = |(Context) throws|;

/// Request context - the primary interface for handlers
struct Context {
    /// The incoming HTTP request
    request: Request,
    
    /// The outgoing HTTP response
    response: Response,
    
    /// Path parameters extracted from route (e.g., :id)
    params: <string, string>,
    
    /// Handler chain (middleware + final handler)
    handlers: [HandlerFunc],
    
    /// Current index in handler chain
    index: int = -1,
    
    /// Key-value store for passing data between middleware
    /// TODO: Replace with proper type once Navi supports dynamic types
    keys: <string, string>,
    
    /// Whether the handler chain was aborted
    aborted: bool = false,

    /// Whether this handler is running in a worker pool thread
    in_worker: bool = false,

    /// Worker pool size (0 if not using worker pool)
    worker_size: int = 0,
}

impl Context {
    /// Create a new Context with request and response
    pub fn new(request: Request, response: Response): Context {
        return Context {
            request,
            response,
            params: {:},
            handlers: [],
            keys: {:},
        };
    }
    
    /// Create context with handlers
    pub fn with_handlers(request: Request, handlers: [HandlerFunc], params: <string, string>): Context {
        return Context {
            request,
            response: Response.new(),
            params,
            handlers,
            keys: {:},
        };
    }
    
    // ============================================
    // Request accessors
    // ============================================
    
    /// Get path parameter by name
    /// 
    /// # Arguments
    /// * `name` - Parameter name (without colon)
    /// 
    /// # Returns
    /// Parameter value or nil if not found
    /// 
    /// # Example
    /// ```nv
    /// // Route: /users/:id
    /// let id = ctx.param("id");  // "123" for /users/123
    /// ```
    pub fn param(self, name: string): string? {
        return self.params.get(name);
    }
    
    /// Get query parameter by name
    ///
    /// # Arguments
    /// * `name` - Query parameter name
    ///
    /// # Returns
    /// Parameter value or nil if not found
    ///
    /// # Example
    /// ```nv
    /// // URL: /users?page=2&limit=10
    /// let page = ctx.query("page") || "1";
    /// ```
    pub fn query(self, name: string): string? {
        return self.request.query(name);
    }

    /// Get query parameter with default value
    ///
    /// # Arguments
    /// * `name` - Query parameter name
    /// * `default` - Default value if parameter not found
    ///
    /// # Returns
    /// Parameter value or default if not found
    ///
    /// # Example
    /// ```nv
    /// // URL: /users?page=2
    /// let page = ctx.default_query("page", "1");  // Returns "2"
    /// let limit = ctx.default_query("limit", "10");  // Returns "10" (not in URL)
    /// ```
    pub fn default_query(self, name: string, default_value: string): string {
        return self.query(name) || default_value;
    }

    /// Get request header by name
    pub fn header(self, name: string): string? {
        return self.request.header(name);
    }
    
    /// Get request body as string
    pub fn body(self): string {
        return self.request.body;
    }
    
    /// Get request method
    pub fn method(self): string {
        return self.request.method;
    }
    
    /// Get request path
    pub fn path(self): string {
        return self.request.path;
    }
    
    /// Get full request URI
    pub fn uri(self): string {
        return self.request.uri;
    }
    
    /// Get Content-Type of request
    pub fn content_type(self): string? {
        return self.request.content_type();
    }
    
    // ============================================
    // Request body parsing
    // ============================================
    
    /// Parse request body as JSON into type T
    /// 
    /// # Returns
    /// Parsed value or throws on parse error
    /// 
    /// # Example
    /// ```nv
    /// struct CreateUser {
    ///     name: string,
    ///     email: string,
    /// }
    /// 
    /// let json_str = try ctx.bind_json();
    /// ```
    ///
    /// TODO: Add generic type support when Navi supports it
    pub fn bind_json(self): string throws {
        let body = self.request.body;
        if (body.len() == 0) {
            throw "Empty request body";
        }
        // Return raw JSON string for now
        return body;
    }
    
    // ============================================
    // Response helpers
    // ============================================
    
    /// Set response status code
    /// 
    /// # Arguments
    /// * `code` - HTTP status code
    /// 
    /// # Returns
    /// Self for chaining
    pub fn status(self, code: int): Context {
        self.response.status(code);
        return self;
    }
    
    /// Set response header
    pub fn set_header(self, name: string, value: string): Context {
        self.response.header(name, value);
        return self;
    }
    
    /// Send JSON response
    ///
    /// # Arguments
    /// * `data` - Data to encode as JSON
    ///
    /// # Example
    /// ```nv
    /// try ctx.json({"message": "Hello", "count": 42});
    /// ```
    pub fn json<T>(self, data: T) throws {
        let body = try json.to_string(data);
        self.response.content_type("application/json; charset=utf-8");
        self.response.write(body);
    }
    
    /// Send plain text response
    pub fn string(self, content: string) {
        self.response.content_type("text/plain; charset=utf-8");
        self.response.write(content);
    }
    
    /// Send HTML response
    pub fn html(self, content: string) {
        self.response.content_type("text/html; charset=utf-8");
        self.response.write(content);
    }

    /// Send XML response
    ///
    /// # Arguments
    /// * `data` - Data to encode as XML
    ///
    /// # Example
    /// ```nv
    /// ctx.xml("<user><name>Alice</name></user>");
    /// ```
    ///
    /// Note: Currently accepts pre-formatted XML string.
    /// Full struct-to-XML serialization pending Navi XML encoder support.
    pub fn xml(self, xml_string: string) {
        self.response.content_type("application/xml; charset=utf-8");
        self.response.write(xml_string);
    }

    /// Send YAML response
    ///
    /// # Arguments
    /// * `data` - Data to encode as YAML
    ///
    /// # Example
    /// ```nv
    /// ctx.yaml("name: Alice\nage: 30\n");
    /// ```
    ///
    /// Note: Currently accepts pre-formatted YAML string.
    /// Full struct-to-YAML serialization pending Navi YAML encoder support.
    pub fn yaml(self, yaml_string: string) {
        self.response.content_type("application/yaml; charset=utf-8");
        self.response.write(yaml_string);
    }

    /// Send raw bytes
    pub fn data(self, content_type: string, data: string) {
        self.response.content_type(content_type);
        self.response.write(data);
    }

    /// Send file with automatic content-type detection
    ///
    /// # Arguments
    /// * `file_path` - Path to file to send
    ///
    /// # Example
    /// ```nv
    /// ctx.file("./static/image.png");
    /// ```
    pub fn file(self, file_path: string) throws {

        // Read file contents
        let contents = try fs.read_to_string(file_path);

        // Detect content type from extension
        let content_type = detect_content_type(file_path);
        self.response.content_type(content_type);

        // Write file contents
        self.response.write(contents);
    }

    /// Send file as download with custom filename
    ///
    /// Sets Content-Disposition header to trigger download.
    ///
    /// # Arguments
    /// * `file_path` - Path to file
    /// * `download_name` - Filename for download (optional, defaults to file basename)
    ///
    /// # Example
    /// ```nv
    /// ctx.download("./reports/data.csv", "report-2024.csv");
    /// ```
    pub fn download(self, file_path: string, download_name: string?) throws {

        // Read file contents
        let contents = try fs.read_to_string(file_path);

        // Determine download filename
        let filename = "";
        if (let name = download_name) {
            filename = name;
        } else {
            // Extract basename from file path
            let parts = file_path.split("/");
            if (parts.len() > 0) {
                filename = parts[parts.len() - 1];
            } else {
                filename = file_path;
            }
        }

        // Set headers for download
        let content_type = detect_content_type(file_path);
        self.response.content_type(content_type);
        self.response.header("Content-Disposition", `attachment; filename="${filename}"`);

        // Write file contents
        self.response.write(contents);
    }

    /// Redirect to another URL
    pub fn redirect(self, code: int, url: string) {
        self.response.status(code);
        self.response.header("Location", url);
    }
    
    // ============================================
    // Middleware control
    // ============================================
    
    /// Execute the next handler in the chain
    /// 
    /// This is the core of middleware functionality. Calling next()
    /// executes the next handler, and code after next() runs after
    /// that handler returns.
    /// 
    /// # Example
    /// ```nv
    /// fn logger(): HandlerFunc {
    ///     return |ctx| {
    ///         let start = time.now();
    ///         try ctx.next();  // Execute rest of chain
    ///         let duration = time.now() - start;
    ///         println(`Request took ${duration}ms`);
    ///     };
    /// }
    /// ```
    pub fn next(self) throws {
        self.index += 1;
        
        while (self.index < self.handlers.len() && !self.aborted) {
            let handler = self.handlers[self.index];
            try handler(self);
            self.index += 1;
        }
    }
    
    /// Abort the handler chain
    /// 
    /// Stops execution of remaining handlers. Usually used after
    /// sending an error response.
    pub fn abort(self) {
        self.aborted = true;
    }
    
    /// Abort with specific status code
    pub fn abort_with_status(self, code: int) {
        self.response.status(code);
        self.abort();
    }
    
    /// Abort with JSON error response
    pub fn abort_with_error(self, code: int, message: string) {
        self.response.status(code);
        self.response.content_type("application/json");
        self.response.write(`{"error": "${message}"}`);
        self.abort();
    }
    
    /// Check if chain was aborted
    pub fn is_aborted(self): bool {
        return self.aborted;
    }
    
    // ============================================
    // Middleware data passing
    // ============================================
    
    /// Store a value in context for later retrieval
    ///
    /// Useful for passing data between middleware.
    ///
    /// # Example
    /// ```nv
    /// // In auth middleware
    /// ctx.set("user_id", "123");
    ///
    /// // In handler
    /// let user_id = ctx.get("user_id");
    /// ```
    pub fn set(self, key: string, value: string) {
        self.keys[key] = value;
    }

    /// Get a value from context
    ///
    /// # Returns
    /// Stored value or nil if not found
    pub fn get(self, key: string): string? {
        return self.keys.get(key);
    }
    
    /// Get a string value from context
    pub fn get_string(self, key: string): string? {
        let value = self.keys.get(key);
        if (let v = value) {
            return v as string;
        }
        return nil;
    }
    
    /// Get an int value from context
    /// NOTE: Since context stores all values as strings, this method
    /// is not currently functional. Use get_string() and parse manually.
    pub fn get_int(self, key: string): int? {
        // TODO: Implement string to int parsing when Navi supports it
        return nil;
    }

    /// Get a bool value from context
    /// Parses the stored string value as a boolean
    pub fn get_bool(self, key: string): bool? {
        let value = self.keys.get(key);
        if (let v = value) {
            if (v == "true") {
                return true;
            } else if (v == "false") {
                return false;
            }
        }
        return nil;
    }

    /// Get a float value from context
    /// NOTE: Since context stores all values as strings, this method
    /// is not currently functional. Use get_string() and parse manually.
    pub fn get_float(self, key: string): float? {
        // TODO: Implement string to float parsing when Navi supports it
        return nil;
    }

    // ============================================
    // Worker pool support
    // ============================================

    /// Check if handler is running in a worker pool thread
    ///
    /// # Returns
    /// true if running in worker pool, false otherwise
    pub fn in_worker_pool(self): bool {
        return self.in_worker;
    }

    /// Get the worker pool size
    ///
    /// # Returns
    /// Worker pool size, or 0 if not using worker pool
    pub fn worker_pool_size(self): int {
        return self.worker_size;
    }

    /// Convert Context to serializable WorkerContext
    ///
    /// Used to send request data to worker threads.
    ///
    /// # Returns
    /// WorkerContext with serializable request data
    pub fn to_worker_context(self): WorkerContext {
        return WorkerContext.new(
            self.request.path,
            self.request.method,
            self.request.headers,
            self.request.query_params,
            self.params,
            self.request.body
        );
    }
}

// ============================================
// Helper Functions
// ============================================

/// Detect content type from file extension
fn detect_content_type(file_path: string): string {
    let lower_path = file_path.to_lowercase();

    // HTML
    if (lower_path.ends_with(".html") || lower_path.ends_with(".htm")) {
        return "text/html; charset=utf-8";
    }

    // CSS
    if (lower_path.ends_with(".css")) {
        return "text/css; charset=utf-8";
    }

    // JavaScript
    if (lower_path.ends_with(".js")) {
        return "application/javascript; charset=utf-8";
    }

    // JSON
    if (lower_path.ends_with(".json")) {
        return "application/json; charset=utf-8";
    }

    // Images
    if (lower_path.ends_with(".png")) {
        return "image/png";
    }
    if (lower_path.ends_with(".jpg") || lower_path.ends_with(".jpeg")) {
        return "image/jpeg";
    }
    if (lower_path.ends_with(".gif")) {
        return "image/gif";
    }
    if (lower_path.ends_with(".svg")) {
        return "image/svg+xml";
    }
    if (lower_path.ends_with(".ico")) {
        return "image/x-icon";
    }

    // Fonts
    if (lower_path.ends_with(".woff")) {
        return "font/woff";
    }
    if (lower_path.ends_with(".woff2")) {
        return "font/woff2";
    }
    if (lower_path.ends_with(".ttf")) {
        return "font/ttf";
    }

    // Documents
    if (lower_path.ends_with(".pdf")) {
        return "application/pdf";
    }
    if (lower_path.ends_with(".xml")) {
        return "application/xml; charset=utf-8";
    }
    if (lower_path.ends_with(".txt")) {
        return "text/plain; charset=utf-8";
    }
    if (lower_path.ends_with(".csv")) {
        return "text/csv; charset=utf-8";
    }

    // Archives
    if (lower_path.ends_with(".zip")) {
        return "application/zip";
    }
    if (lower_path.ends_with(".tar")) {
        return "application/x-tar";
    }
    if (lower_path.ends_with(".gz")) {
        return "application/gzip";
    }

    // Default
    return "application/octet-stream";
}

// ============================================
// Tests
// ============================================

test "create context" {
    let req = try! Request.parse("GET /test HTTP/1.1\r\nHost: localhost\r\n\r\n");
    let ctx = Context.new(req, Response.new());
    
    assert_eq ctx.method(), "GET";
    assert_eq ctx.path(), "/test";
}

test "access query params" {
    let req = try! Request.parse("GET /test?page=2&limit=10 HTTP/1.1\r\nHost: localhost\r\n\r\n");
    let ctx = Context.new(req, Response.new());
    
    assert_eq ctx.query("page"), "2";
    assert_eq ctx.query("limit"), "10";
    assert_eq ctx.query("missing"), nil;
}

test "set and get context values" {
    let req = try! Request.parse("GET / HTTP/1.1\r\nHost: localhost\r\n\r\n");
    let ctx = Context.new(req, Response.new());

    ctx.set("user_id", "123");
    ctx.set("role", "admin");

    // Note: get_int/get_float are not yet implemented
    assert_eq ctx.get_string("user_id"), "123";
    assert_eq ctx.get_string("role"), "admin";
    assert_eq ctx.get("missing"), nil;
}

test "response helpers" {
    let req = try! Request.parse("GET / HTTP/1.1\r\nHost: localhost\r\n\r\n");
    let ctx = Context.new(req, Response.new());
    
    ctx.status(201).set_header("X-Custom", "value");
    ctx.string("Created");
    
    assert_eq ctx.response.status_code, 201;
    assert_eq ctx.response.get_header("X-Custom"), "value";
    assert ctx.response.body.contains("Created");
}

test "abort chain" {
    let req = try! Request.parse("GET / HTTP/1.1\r\nHost: localhost\r\n\r\n");
    let ctx = Context.new(req, Response.new());
    
    assert_eq ctx.is_aborted(), false;
    
    ctx.abort_with_status(401);
    
    assert_eq ctx.is_aborted(), true;
    assert_eq ctx.response.status_code, 401;
}

test "path params" {
    let req = try! Request.parse("GET /users/123 HTTP/1.1\r\nHost: localhost\r\n\r\n");
    let params: <string, string> = {"id": "123"};
    let ctx = Context.with_handlers(req, [], params);

    assert_eq ctx.param("id"), "123";
    assert_eq ctx.param("missing"), nil;
}

test "check not in worker pool by default" {
    let req = try! Request.parse("GET / HTTP/1.1\r\nHost: localhost\r\n\r\n");
    let ctx = Context.new(req, Response.new());

    assert_eq ctx.in_worker_pool(), false;
    assert_eq ctx.worker_pool_size(), 0;
}

test "convert context to worker context" {
    let req = try! Request.parse("GET /users/123?page=1 HTTP/1.1\r\nHost: localhost\r\n\r\nbody");
    let params: <string, string> = {"id": "123"};
    let ctx = Context.with_handlers(req, [], params);

    let worker_ctx = ctx.to_worker_context();

    assert_eq worker_ctx.path, "/users/123";
    assert_eq worker_ctx.method, "GET";
    assert_eq worker_ctx.params.get("id"), "123";
    assert_eq worker_ctx.query.get("page"), "1";
    assert_eq worker_ctx.body, "body";
}
