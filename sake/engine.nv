/// Sake Web Framework Engine
///
/// Engine is the core of the Sake framework. It manages the HTTP server,
/// routing, middleware, and request handling with support for both
/// concurrent (spawn) and parallel (WorkerPool) execution.
///
/// # Example
/// ```nv
/// use sake.Engine;
/// use sake.Config;
///
/// fn main() throws {
///     let config = Config.with_defaults();
///     let app = Engine.new(config);
///
///     app.get("/", |ctx| {
///         ctx.string("Hello!");
///     });
///
///     try app.run(":8080");
/// }
/// ```

use std.net.{TcpListener, TcpConnection};
use std.io.BufReader;
use std.time;
// Note: config, router, context, request, response, worker_pool are in same module

/// Sake web framework engine
pub struct Engine {
    /// Router for route matching
    router: Router,

    /// Configuration
    config: Config,

    /// Global middleware applied to all routes
    middleware: [HandlerFunc],

    /// Shutdown channel
    shutdown_ch: channel<bool>?,

    /// Worker pool for CPU-intensive routes
    worker_pool: WorkerPool?,

    /// Connection counter channel (send +1 to increment, -1 to decrement)
    conn_counter_ch: channel<int>?,

    /// Connection query channel (send unit, receive current count)
    conn_query_ch: channel<int>?,
}

impl Engine {
    /// Create a new Engine with given configuration
    ///
    /// # Arguments
    /// * `config` - Framework configuration
    ///
    /// # Returns
    /// New Engine instance
    pub fn new(config: Config): Engine {
        return Engine {
            router: Router.new(),
            config,
            middleware: [],
            shutdown_ch: nil,
            worker_pool: nil,
            conn_counter_ch: nil,
            conn_query_ch: nil,
        };
    }

    /// Create a new Engine with default configuration
    pub fn with_defaults(): Engine {
        return Engine.new(Config.with_defaults());
    }

    /// Register a GET route
    ///
    /// # Arguments
    /// * `path` - Route path (supports :param syntax)
    /// * `handler` - Handler function
    ///
    /// # Returns
    /// RouteBuilder for further configuration (e.g., .worker())
    ///
    /// # Example
    /// ```nv
    /// app.get("/users/:id", |ctx| {
    ///     let id = ctx.param("id");
    ///     ctx.json({"id": id});
    /// });
    ///
    /// // For CPU-intensive routes:
    /// app.get("/compute/:n", |ctx| {
    ///     let result = expensive_computation();
    ///     ctx.json({"result": result});
    /// }).worker();
    /// ```
    pub fn get(self, path: string, handler: HandlerFunc): RouteBuilder {
        return self.router.add_route("GET", path, handler);
    }

    /// Register a POST route
    pub fn post(self, path: string, handler: HandlerFunc): RouteBuilder {
        return self.router.add_route("POST", path, handler);
    }

    /// Register a PUT route
    pub fn put(self, path: string, handler: HandlerFunc): RouteBuilder {
        return self.router.add_route("PUT", path, handler);
    }

    /// Register a DELETE route
    pub fn delete(self, path: string, handler: HandlerFunc): RouteBuilder {
        return self.router.add_route("DELETE", path, handler);
    }

    /// Register a PATCH route
    pub fn patch(self, path: string, handler: HandlerFunc): RouteBuilder {
        return self.router.add_route("PATCH", path, handler);
    }

    /// Register an OPTIONS route
    pub fn options(self, path: string, handler: HandlerFunc): RouteBuilder {
        return self.router.add_route("OPTIONS", path, handler);
    }

    /// Register a HEAD route
    pub fn head(self, path: string, handler: HandlerFunc): RouteBuilder {
        return self.router.add_route("HEAD", path, handler);
    }

    /// Register a route that matches ALL HTTP methods
    ///
    /// Registers the same handler for GET, POST, PUT, DELETE, PATCH, OPTIONS, and HEAD.
    ///
    /// # Arguments
    /// * `path` - Route path (supports :param and *wildcard syntax)
    /// * `handler` - Handler function
    ///
    /// # Example
    /// ```nv
    /// app.any("/ping", |ctx| {
    ///     ctx.json({"message": "pong"});
    /// });
    /// ```
    pub fn any(self, path: string, handler: HandlerFunc) {
        self.router.add_route("GET", path, handler);
        self.router.add_route("POST", path, handler);
        self.router.add_route("PUT", path, handler);
        self.router.add_route("DELETE", path, handler);
        self.router.add_route("PATCH", path, handler);
        self.router.add_route("OPTIONS", path, handler);
        self.router.add_route("HEAD", path, handler);
    }

    /// Add global middleware
    ///
    /// # Arguments
    /// * `middleware` - Middleware handler function
    ///
    /// # Example
    /// ```nv
    /// app.add_middleware(|ctx| {
    ///     println("Request received");
    ///     try ctx.next();
    /// });
    /// ```
    pub fn add_middleware(self, middleware: HandlerFunc) {
        self.middleware.push(middleware);
    }

    /// Create a route group with common path prefix
    ///
    /// RouterGroups allow organizing routes with common prefixes and middleware.
    ///
    /// # Arguments
    /// * `path` - Path prefix for all routes in this group
    ///
    /// # Returns
    /// RouterGroup instance for adding routes
    ///
    /// # Example
    /// ```nv
    /// // Create API v1 group
    /// let v1 = app.group("/api/v1");
    /// v1.add_middleware(auth_middleware);
    /// v1.get("/users", |ctx| {
    ///     ctx.json({"users": []});
    /// });
    ///
    /// // Create nested admin group
    /// let admin = v1.group("/admin");
    /// admin.get("/settings", |ctx| {
    ///     ctx.json({"settings": {}});
    /// });
    /// ```
    pub fn group(self, path: string): RouterGroup {
        return RouterGroup.new(self.router, path, []);
    }

    /// Start the HTTP server
    ///
    /// # Arguments
    /// * `addr` - Address to listen on (e.g., ":8080", "127.0.0.1:3000")
    ///
    /// # Errors
    /// Throws if server fails to start or encounters error during operation
    ///
    /// # Example
    /// ```nv
    /// try app.run(":8080");
    /// ```
    pub fn run(self, addr: string) throws {
        // Validate configuration
        try self.config.validate();

        // Log configuration
        println("üç∂ Sake Framework");
        println("==================");
        println(`Server address: ${addr}`);
        println(`Max connections: ${self.config.max_connections}`);
        println(`Request timeout: ${self.config.request_timeout}ms`);

        // Initialize shutdown channel
        let shutdown_ch = channel::<bool>();
        self.shutdown_ch = shutdown_ch;

        // Initialize connection counter channels
        let conn_counter_ch = channel::<int>();
        let conn_query_ch = channel::<int>();
        self.conn_counter_ch = conn_counter_ch;
        self.conn_query_ch = conn_query_ch;

        // Spawn connection counter task
        spawn {
            let count = 0;
            while (true) {
                // Try to receive counter update (+1 or -1)
                let update_opt = try? conn_counter_ch.try_recv();
                if (update_opt != nil) {
                    count += update_opt!!;
                }

                // Try to receive query request
                let query_opt = try? conn_query_ch.try_recv();
                if (query_opt != nil) {
                    try! conn_query_ch.send(count);
                }
            }
        }

        // Initialize WorkerPool if enabled
        if (self.config.enable_worker_pool) {
            let pool_size = self.config.effective_worker_pool_size();
            println(`Worker pool: enabled (${pool_size} threads)`);
            self.worker_pool = try WorkerPool.new(pool_size);
        } else {
            println("Worker pool: disabled (spawn mode only)");
        }

        // Start TCP listener
        let listener = try TcpListener.bind(addr);
        println("==================");
        println(`üç∂ Server ready at ${addr}`);

        // Accept connections loop
        while (true) {
            // Check for shutdown signal (non-blocking)
            if (let ch = self.shutdown_ch) {
                let should_stop = try? ch.try_recv();
                if (should_stop != nil) {
                    println("üç∂ Sake server shutting down...");
                    break;
                }
            }

            // Check max connections limit
            if (let query_ch = self.conn_query_ch) {
                if (let counter_ch = self.conn_counter_ch) {
                    // Query current connection count
                    try! query_ch.send(0);
                    let current_count = try query_ch.recv();

                    if (current_count >= self.config.max_connections) {
                        // Connection limit reached - sleep briefly to avoid busy loop
                        time.sleep(0.01.seconds());
                        continue;
                    }
                }
            }

            // Accept next connection
            let stream_result = try? listener.accept_tcp();
            if (let stream = stream_result) {
                // Increment active connections
                if (let counter_ch = self.conn_counter_ch) {
                    try! counter_ch.send(1);
                }

                // Handle connection (not using spawn for now to avoid variable capture issues)
                // TODO: Re-enable spawn for concurrency once variable capture is resolved
                defer {
                    // Decrement active connections
                    if (let counter_ch = self.conn_counter_ch) {
                        try! counter_ch.send(-1);
                    }
                }

                try? self.handle_connection(stream);
            }
        }

        println("üç∂ Sake server stopped");
    }

    /// Handle a single client connection
    ///
    /// # Arguments
    /// * `stream` - TCP stream for the connection
    fn handle_connection(self, stream: TcpConnection) throws {
        defer {
            try? stream.close();
        }

        // Read request with timeout
        // Note: Timeout enforcement requires async/await or thread-based timeouts.
        // Current implementation (spawn) is single-threaded concurrent, making
        // request-level timeouts challenging without blocking the entire runtime.
        // Consider using TcpStream.set_read_timeout() if available in Navi stdlib.
        // For now, request_timeout config is used for documentation only.

        // Read raw HTTP request
        let reader = BufReader.new(stream);
        let raw_request = try reader.read_to_string();

        // Parse HTTP request
        let request = try self.parse_request_or_error(raw_request);

        // Match route
        let route_match = self.router.find_match(request.method, request.path);

        if (let matched_route = route_match) {
            // Check if this route should use worker pool
            let has_worker_pool = false;
            if (let _ = self.worker_pool) {
                has_worker_pool = true;
            }

            let use_worker = matched_route.route.worker_mode == WorkerMode.Worker &&
                            self.config.enable_worker_pool &&
                            has_worker_pool;

            if (use_worker) {
                // Execute in worker pool
                try self.handle_worker_execution(stream, request, matched_route);
            } else {
                // Execute with spawn (default)
                try self.handle_spawn_execution(stream, request, matched_route);
            }
        } else {
            // No route found - send 404
            let response = Response.not_found();
            try response.send(stream);
        }
    }

    /// Handle request execution in spawn mode (concurrent, single-threaded)
    ///
    /// Builds the complete handler chain:
    /// 1. Global middleware (from app.add_middleware())
    /// 2. Group middleware (from group.add_middleware())
    /// 3. Route middleware (from route.add_middleware())
    /// 4. Route handler
    ///
    /// # Arguments
    /// * `stream` - TCP stream
    /// * `request` - Parsed HTTP request
    /// * `route_match` - Matched route with parameters
    fn handle_spawn_execution(
        self,
        stream: TcpConnection,
        request: Request,
        route_match: RouteMatch
    ) throws {
        // Build handler chain: global middleware + route middleware + handler
        let handlers: [HandlerFunc] = [];

        // 1. Add global middleware
        for (let mw in self.middleware) {
            handlers.push(mw);
        }

        // 2. Add route-specific middleware (includes group middleware if from group)
        for (let mw in route_match.route.middleware) {
            handlers.push(mw);
        }

        // 3. Add route handler
        handlers.push(route_match.route.handler);

        // Create context
        let ctx = Context.with_handlers(request, handlers, route_match.params);

        // Execute handler chain
        try ctx.next();

        // Send response
        try ctx.response.send(stream);
    }

    /// Handle request execution in worker pool mode (parallel, multi-threaded)
    ///
    /// # Arguments
    /// * `stream` - TCP stream
    /// * `request` - Parsed HTTP request
    /// * `route_match` - Matched route with parameters
    fn handle_worker_execution(
        self,
        stream: TcpConnection,
        request: Request,
        route_match: RouteMatch
    ) throws {
        // Serialize context for worker
        let ctx = Context.with_handlers(request, [], route_match.params);
        ctx.in_worker = true;
        ctx.worker_size = self.config.effective_worker_pool_size();

        let worker_ctx = ctx.to_worker_context();
        let ctx_json = try worker_ctx.to_json();

        // Submit to worker pool
        if (let pool = self.worker_pool) {
            let worker_response = try pool.submit(ctx_json, 0);

            // Build response from worker result
            let response = Response.new();
            response.status(worker_response.status);

            for (let name, value in worker_response.headers) {
                response.header(name, value);
            }

            response.write(worker_response.body);

            // Send response
            try response.send(stream);
        } else {
            throw "Worker pool not initialized";
        }
    }

    /// Parse request or return error response
    ///
    /// # Arguments
    /// * `raw` - Raw HTTP request string
    ///
    /// # Returns
    /// Parsed Request or throws on error
    fn parse_request_or_error(self, raw: string): Request throws {
        do {
            let request = try Request.parse(raw);
            return request;
        } catch (e) {
            // Log parse error
            println(`Error parsing request: ${e.error()}`);
            throw "Malformed request";
        }
    }

    /// Shutdown the server gracefully
    ///
    /// Signals the server to stop accepting new connections
    /// and wait for existing requests to complete.
    pub fn shutdown(self) throws {
        if (let ch = self.shutdown_ch) {
            try ch.send(true);
        }

        // Shutdown worker pool if initialized
        if (let pool = self.worker_pool) {
            try pool.shutdown();
        }
    }
}

// ============================================
// Tests
// ============================================

test "create engine with default config" {
    let app = Engine.with_defaults();
    assert_eq app.config.worker_pool_size, 0;
    assert_eq app.config.enable_worker_pool, true;
}

test "create engine with custom config" {
    let config = Config.with_defaults().with_worker_pool_size(4);
    let app = Engine.new(config);
    assert_eq app.config.worker_pool_size, 4;
}

// TODO: Re-enable test once Navi supports closure type inference
// test "register GET route" { ... }

// TODO: Re-enable tests once Navi supports closure type inference in route handlers
// test "register multiple routes" { ... }
// test "add middleware" { ... }
// test "register OPTIONS route" { ... }
// test "register HEAD route" { ... }
// test "register ANY route" { ... }
