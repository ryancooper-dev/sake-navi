// 测试 Worker 与 TCP 连接的集成
// 这是 Sake 并行处理的关键验证
// 运行: navi run test_worker_tcp.nv

use std.vm;
use std.worker.Worker;
use std.net.TcpListener;
use std.time;
use std.sync.freeze;

/// Worker pool handler function
fn request_handler(req: string): string throws {
    let tid = Worker.thread_id();
    return `处理完成 by thread ${tid}: ${req}`;
}

/// Configuration for worker handlers
struct WorkerConfig {
    max_requests: int,
    timeout_ms: int,
}

fn main() throws {
    println("=== Worker + TCP 集成测试 ===\n");

    // 启动测试服务器
    let listener = try TcpListener.bind("127.0.0.1:0");
    let addr = try listener.tcp_addr();
    println(`服务器启动: ${addr}`);
    try listener.close();

    // 测试 1: WorkerPool 处理请求
    println("\n测试 1: WorkerPool 请求处理");
    test_worker_pool_request();

    // 测试 2: Frozen<T> 跨线程数据共享
    println("\n测试 2: Frozen<T> 跨线程共享");
    test_frozen_cross_thread();

    // 测试 3: Worker 通信
    println("\n测试 3: Worker 通信");
    try test_worker_communication();

    println("\n=== 测试完成 ===");
}

fn test_worker_pool_request() {
    // 模拟请求处理
    let pool = try! Worker.pool(request_handler);

    let results = try! pool.map_array([
        "GET /",
        "GET /api/users",
        "POST /api/data",
        "GET /health",
    ]);

    for (let r in results) {
        println(`  ${r}`);
    }
    println("  ✅ WorkerPool 请求处理正常");
}

fn test_frozen_cross_thread() {
    // 创建 Frozen 配置
    let config = try! freeze(WorkerConfig {
        max_requests: 100,
        timeout_ms: 5000,
    });

    // 获取值并验证
    let value = try! config.get();
    println(`  config.max_requests = ${value.max_requests}`);
    println(`  config.timeout_ms = ${value.timeout_ms}`);

    // 多次获取验证独立副本
    let v1 = try! config.get();
    let v2 = try! config.get();
    assert_eq v1.max_requests, v2.max_requests;

    println("  ✅ Frozen<T> 跨线程共享正常");
}

fn test_worker_communication() throws {
    // 创建处理连接的 Worker
    let handler = try Worker.create(|w| {
        // 等待消息
        let msg_opt = try w.recv::<string>();
        if (let msg = msg_opt) {
            println(`  Worker 收到: ${msg}`);
        }
        try w.send("已处理");
    });

    // 发送消息
    try handler.send("测试消息");
    let result_opt = try handler.recv::<string>();
    if (let result = result_opt) {
        println(`  主线程收到: ${result}`);
    }
    println("  ✅ Worker 通信正常");
}
