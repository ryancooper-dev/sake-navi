/// Comprehensive Middleware Tests for Sake Framework
///
/// Tests all built-in middleware:
/// - Logger middleware
/// - Recovery middleware
/// - CORS middleware
/// - BasicAuth middleware
///
/// Tests middleware configuration, execution order, and error handling.

use context.{Context, HandlerFunc};
use request.Request;
use middleware.logger.{logger, logger_with_config, LoggerConfig};
use middleware.recovery.{recovery, recovery_with_config, RecoveryConfig};
use middleware.cors.{cors, cors_with_config, CorsConfig};
use middleware.basic_auth.{basic_auth, basic_auth_with_config, BasicAuthConfig, Account};

// ============================================
// Logger Middleware Tests
// ============================================

test "logger middleware executes handler" {
    let request = try! Request.parse("GET /test HTTP/1.1\r\n\r\n");

    let handler = |ctx| {
        ctx.string("Response");
    };

    let ctx = Context.with_handlers(request, [logger(), handler], {:});
    try! ctx.next();

    assert ctx.response.body.contains("Response");
}

test "logger config without colors" {
    let config = LoggerConfig.with_defaults().without_colors();

    assert_eq config.use_colors, false;
}

test "logger with disabled logging" {
    let config = LoggerConfig {
        use_colors: false,
        log_requests: false,
    };

    let request = try! Request.parse("GET /test HTTP/1.1\r\n\r\n");
    let handler = |ctx| { ctx.string("OK"); };

    let ctx = Context.with_handlers(request, [logger_with_config(config), handler], {:});
    try! ctx.next();

    assert ctx.response.body.contains("OK");
}

// ============================================
// Recovery Middleware Tests
// ============================================

test "recovery catches and handles errors" {
    let request = try! Request.parse("GET /test HTTP/1.1\r\n\r\n");

    let failing_handler = |ctx| {
        throw "Simulated error";
    };

    let ctx = Context.with_handlers(request, [recovery(), failing_handler], {:});
    try! ctx.next();

    // Should return 500 error
    let response_text = ctx.response.build();
    assert response_text.contains("500");
    assert response_text.contains("Internal Server Error");
    assert ctx.is_aborted();
}

test "recovery allows successful requests through" {
    let request = try! Request.parse("GET /test HTTP/1.1\r\n\r\n");

    let success_handler = |ctx| {
        ctx.json({"status": "ok"});
    };

    let ctx = Context.with_handlers(request, [recovery(), success_handler], {:});
    try! ctx.next();

    // Should complete successfully
    assert !ctx.is_aborted();
}

test "recovery with error details" {
    let request = try! Request.parse("GET /test HTTP/1.1\r\n\r\n");

    let failing_handler = |ctx| {
        throw "Custom error message";
    };

    let config = RecoveryConfig.with_defaults().with_details();
    let ctx = Context.with_handlers(request, [recovery_with_config(config), failing_handler], {:});
    try! ctx.next();

    let response_text = ctx.response.build();
    assert response_text.contains("Custom error message");
}

test "recovery without stack trace" {
    let config = RecoveryConfig.with_defaults().without_stack();

    assert_eq config.print_stack, false;
}

// ============================================
// CORS Middleware Tests
// ============================================

test "cors adds headers to regular requests" {
    let request = try! Request.parse("GET /test HTTP/1.1\r\nOrigin: https://example.com\r\n\r\n");

    let handler = |ctx| {
        ctx.string("OK");
    };

    let ctx = Context.with_handlers(request, [cors(), handler], {:});
    try! ctx.next();

    let response_text = ctx.response.build();
    assert response_text.contains("Access-Control-Allow-Origin");
}

test "cors handles preflight OPTIONS request" {
    let request = try! Request.parse("OPTIONS /test HTTP/1.1\r\nOrigin: https://example.com\r\n\r\n");

    let handler = |ctx| {
        ctx.string("Should not reach");
    };

    let ctx = Context.with_handlers(request, [cors(), handler], {:});
    try! ctx.next();

    // Preflight should abort chain
    assert ctx.is_aborted();

    let response_text = ctx.response.build();
    assert response_text.contains("204");
    assert response_text.contains("Access-Control-Allow-Methods");
    assert response_text.contains("Access-Control-Allow-Headers");
}

test "cors with specific origins" {
    let config = CorsConfig.with_defaults()
        .with_origins(["https://example.com", "https://test.com"]);

    let request = try! Request.parse("GET /test HTTP/1.1\r\nOrigin: https://example.com\r\n\r\n");
    let handler = |ctx| { ctx.string("OK"); };

    let ctx = Context.with_handlers(request, [cors_with_config(config), handler], {:});
    try! ctx.next();

    let response_text = ctx.response.build();
    assert response_text.contains("Access-Control-Allow-Origin: https://example.com");
}

test "cors with credentials" {
    let config = CorsConfig.with_defaults().with_credentials();

    let request = try! Request.parse("GET /test HTTP/1.1\r\nOrigin: https://example.com\r\n\r\n");
    let handler = |ctx| { ctx.string("OK"); };

    let ctx = Context.with_handlers(request, [cors_with_config(config), handler], {:});
    try! ctx.next();

    let response_text = ctx.response.build();
    assert response_text.contains("Access-Control-Allow-Credentials: true");
}

test "cors with exposed headers" {
    let config = CorsConfig.with_defaults()
        .with_exposed_headers(["X-Custom-Header", "X-Another-Header"]);

    let request = try! Request.parse("GET /test HTTP/1.1\r\nOrigin: https://example.com\r\n\r\n");
    let handler = |ctx| { ctx.string("OK"); };

    let ctx = Context.with_handlers(request, [cors_with_config(config), handler], {:});
    try! ctx.next();

    let response_text = ctx.response.build();
    assert response_text.contains("Access-Control-Expose-Headers");
}

test "cors with custom max age" {
    let config = CorsConfig.with_defaults().with_max_age(7200);

    assert_eq config.max_age, 7200;
}

// ============================================
// BasicAuth Middleware Tests
// ============================================

test "basic_auth allows valid credentials" {
    let accounts = [
        Account.new("alice", "password123"),
        Account.new("bob", "secret456"),
    ];

    // Base64 encoded "alice:password123"
    let request = try! Request.parse("GET /test HTTP/1.1\r\nAuthorization: Basic YWxpY2U6cGFzc3dvcmQxMjM=\r\n\r\n");

    let handler = |ctx| {
        ctx.string("Protected resource");
    };

    let ctx = Context.with_handlers(request, [basic_auth(accounts), handler], {:});
    try! ctx.next();

    // Should reach handler
    assert ctx.response.body.contains("Protected resource");

    // Should set user in context
    assert_eq ctx.get_string("auth_user"), "alice";
}

test "basic_auth rejects invalid credentials" {
    let accounts = [Account.new("admin", "secret")];

    // Base64 encoded "admin:wrongpassword"
    let request = try! Request.parse("GET /test HTTP/1.1\r\nAuthorization: Basic YWRtaW46d3JvbmdwYXNzd29yZA==\r\n\r\n");

    let handler = |ctx| {
        ctx.string("Should not reach");
    };

    let ctx = Context.with_handlers(request, [basic_auth(accounts), handler], {:});
    try! ctx.next();

    // Should abort
    assert ctx.is_aborted();

    let response_text = ctx.response.build();
    assert response_text.contains("401");
    assert response_text.contains("Unauthorized");
}

test "basic_auth rejects missing authorization header" {
    let accounts = [Account.new("admin", "secret")];

    let request = try! Request.parse("GET /test HTTP/1.1\r\n\r\n");

    let handler = |ctx| {
        ctx.string("Should not reach");
    };

    let ctx = Context.with_handlers(request, [basic_auth(accounts), handler], {:});
    try! ctx.next();

    // Should return 401 with WWW-Authenticate header
    assert ctx.is_aborted();

    let response_text = ctx.response.build();
    assert response_text.contains("401");
    assert response_text.contains("WWW-Authenticate");
}

test "basic_auth with custom realm" {
    let config = BasicAuthConfig.with_accounts([Account.new("user", "pass")])
        .with_realm("Admin Area");

    let request = try! Request.parse("GET /test HTTP/1.1\r\n\r\n");
    let handler = |ctx| { ctx.string("OK"); };

    let ctx = Context.with_handlers(request, [basic_auth_with_config(config), handler], {:});
    try! ctx.next();

    let response_text = ctx.response.build();
    assert response_text.contains("Admin Area");
}

test "basic_auth with custom unauthorized message" {
    let config = BasicAuthConfig.with_accounts([Account.new("user", "pass")])
        .with_message("Access Denied");

    let request = try! Request.parse("GET /test HTTP/1.1\r\n\r\n");
    let handler = |ctx| { ctx.string("OK"); };

    let ctx = Context.with_handlers(request, [basic_auth_with_config(config), handler], {:});
    try! ctx.next();

    let response_text = ctx.response.build();
    assert response_text.contains("Access Denied");
}

// ============================================
// Middleware Chaining Tests
// ============================================

test "multiple middleware execute in order" {
    let request = try! Request.parse("GET /test HTTP/1.1\r\nOrigin: https://example.com\r\n\r\n");

    let order: [string] = [];

    let mw1 = |ctx| {
        order.push("mw1-before");
        try ctx.next();
        order.push("mw1-after");
    };

    let mw2 = |ctx| {
        order.push("mw2-before");
        try ctx.next();
        order.push("mw2-after");
    };

    let handler = |ctx| {
        order.push("handler");
        ctx.string("OK");
    };

    let ctx = Context.with_handlers(request, [mw1, mw2, handler], {:});
    try! ctx.next();

    // Verify execution order
    assert_eq order.len(), 5;
    assert_eq order[0], "mw1-before";
    assert_eq order[1], "mw2-before";
    assert_eq order[2], "handler";
    assert_eq order[3], "mw2-after";
    assert_eq order[4], "mw1-after";
}

test "middleware chain with recovery and logger" {
    let request = try! Request.parse("GET /test HTTP/1.1\r\n\r\n");

    let handler = |ctx| {
        ctx.json({"status": "success"});
    };

    let ctx = Context.with_handlers(request, [logger(), recovery(), handler], {:});
    try! ctx.next();

    // Should complete successfully
    assert !ctx.is_aborted();
}

test "middleware chain with cors and basic_auth" {
    let accounts = [Account.new("admin", "secret")];

    // Valid credentials: admin:secret
    let request = try! Request.parse("GET /test HTTP/1.1\r\nOrigin: https://example.com\r\nAuthorization: Basic YWRtaW46c2VjcmV0\r\n\r\n");

    let handler = |ctx| {
        ctx.string("Protected content");
    };

    let ctx = Context.with_handlers(request, [cors(), basic_auth(accounts), handler], {:});
    try! ctx.next();

    // Should pass both middleware
    assert ctx.response.body.contains("Protected content");

    let response_text = ctx.response.build();
    assert response_text.contains("Access-Control-Allow-Origin");
}

test "recovery catches error after other middleware" {
    let request = try! Request.parse("GET /test HTTP/1.1\r\n\r\n");

    let failing_handler = |ctx| {
        throw "Error after logger";
    };

    let ctx = Context.with_handlers(request, [logger(), recovery(), failing_handler], {:});
    try! ctx.next();

    // Recovery should catch error
    let response_text = ctx.response.build();
    assert response_text.contains("500");
}
