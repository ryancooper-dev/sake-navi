/// Sake Web Framework Engine
///
/// Engine is the core of the Sake framework. It manages the HTTP server,
/// routing, middleware, and request handling with support for both
/// concurrent (spawn) and parallel (WorkerPool) execution.
///
/// # Example
/// ```nv
/// use sake.Engine;
/// use sake.Config;
///
/// fn main() throws {
///     let config = Config.default();
///     let app = Engine.new(config);
///
///     app.get("/", |ctx| {
///         ctx.string("Hello!");
///     });
///
///     try app.run(":8080");
/// }
/// ```

use std.net.{TcpListener, TcpStream};
use std.io.{BufReader};
use config.Config;
use router.Router;
use context.{Context, HandlerFunc};
use request.Request;
use response.Response;

/// Sake web framework engine
pub struct Engine {
    /// Router for route matching
    router: Router,

    /// Configuration
    config: Config,

    /// Global middleware applied to all routes
    middleware: [HandlerFunc],

    /// Shutdown channel
    shutdown_ch: channel::<bool>?,
}

impl Engine {
    /// Create a new Engine with given configuration
    ///
    /// # Arguments
    /// * `config` - Framework configuration
    ///
    /// # Returns
    /// New Engine instance
    pub fn new(config: Config): Engine {
        return Engine {
            router: Router.new(),
            config,
            middleware: [],
            shutdown_ch: nil,
        };
    }

    /// Create a new Engine with default configuration
    pub fn default(): Engine {
        return Engine.new(Config.default());
    }

    /// Register a GET route
    ///
    /// # Arguments
    /// * `path` - Route path (supports :param syntax)
    /// * `handler` - Handler function
    ///
    /// # Example
    /// ```nv
    /// app.get("/users/:id", |ctx| {
    ///     let id = ctx.param("id");
    ///     ctx.json({"id": id});
    /// });
    /// ```
    pub fn get(self, path: string, handler: HandlerFunc) {
        self.router.add_route("GET", path, handler);
    }

    /// Register a POST route
    pub fn post(self, path: string, handler: HandlerFunc) {
        self.router.add_route("POST", path, handler);
    }

    /// Register a PUT route
    pub fn put(self, path: string, handler: HandlerFunc) {
        self.router.add_route("PUT", path, handler);
    }

    /// Register a DELETE route
    pub fn delete(self, path: string, handler: HandlerFunc) {
        self.router.add_route("DELETE", path, handler);
    }

    /// Register a PATCH route
    pub fn patch(self, path: string, handler: HandlerFunc) {
        self.router.add_route("PATCH", path, handler);
    }

    /// Add global middleware
    ///
    /// # Arguments
    /// * `middleware` - Middleware handler function
    ///
    /// # Example
    /// ```nv
    /// app.use(|ctx| {
    ///     println("Request received");
    ///     try ctx.next();
    /// });
    /// ```
    pub fn use(self, middleware: HandlerFunc) {
        self.middleware.push(middleware);
    }

    /// Start the HTTP server
    ///
    /// # Arguments
    /// * `addr` - Address to listen on (e.g., ":8080", "127.0.0.1:3000")
    ///
    /// # Errors
    /// Throws if server fails to start or encounters error during operation
    ///
    /// # Example
    /// ```nv
    /// try app.run(":8080");
    /// ```
    pub fn run(self, addr: string) throws {
        // Validate configuration
        try self.config.validate();

        // Initialize shutdown channel
        let shutdown_ch = channel::<bool>();
        self.shutdown_ch = shutdown_ch;

        // TODO: Initialize WorkerPool if enabled

        // Start TCP listener
        let listener = try TcpListener.bind(addr);
        println(`üç∂ Sake server listening on ${addr}`);

        // Accept connections loop
        while (true) {
            // Check for shutdown signal (non-blocking)
            if (let ch = self.shutdown_ch) {
                let should_stop = try? ch.try_recv();
                if (should_stop != nil) {
                    println("üç∂ Sake server shutting down...");
                    break;
                }
            }

            // Accept next connection
            let stream_result = try? listener.accept();
            if (let stream = stream_result) {
                // Spawn handler for this connection
                spawn {
                    try? self.handle_connection(stream);
                }
            }
        }

        println("üç∂ Sake server stopped");
    }

    /// Handle a single client connection
    ///
    /// # Arguments
    /// * `stream` - TCP stream for the connection
    fn handle_connection(self, stream: TcpStream) throws {
        defer {
            stream.close();
        }

        // Read request with timeout
        // TODO: Apply request_timeout from config

        // Read raw HTTP request
        let reader = BufReader.new(stream);
        let raw_request = try reader.read_to_string();

        // Parse HTTP request
        let request = try self.parse_request_or_error(raw_request);

        // Match route
        let route_match = self.router.match(request.method, request.path);

        if (let match = route_match) {
            // Build handler chain: global middleware + route handler
            let handlers: [HandlerFunc] = [];

            // Add global middleware
            for (let mw in self.middleware) {
                handlers.push(mw);
            }

            // Add route handler
            handlers.push(match.route.handler);

            // Create context
            let ctx = Context.with_handlers(request, handlers, match.params);

            // Execute handler chain
            try ctx.next();

            // Send response
            try ctx.response.send(stream);
        } else {
            // No route found - send 404
            let response = Response.not_found();
            try response.send(stream);
        }
    }

    /// Parse request or return error response
    ///
    /// # Arguments
    /// * `raw` - Raw HTTP request string
    ///
    /// # Returns
    /// Parsed Request or throws on error
    fn parse_request_or_error(self, raw: string): Request throws {
        do {
            let request = try Request.parse(raw);
            return request;
        } catch (e) {
            // Log parse error
            println(`Error parsing request: ${e.error()}`);
            throw "Malformed request";
        }
    }

    /// Shutdown the server gracefully
    ///
    /// Signals the server to stop accepting new connections
    /// and wait for existing requests to complete.
    pub fn shutdown(self) throws {
        if (let ch = self.shutdown_ch) {
            try ch.send(true);
        }
    }
}

// ============================================
// Tests
// ============================================

test "create engine with default config" {
    let app = Engine.default();
    assert_eq app.config.worker_pool_size, 0;
    assert_eq app.config.enable_worker_pool, true;
}

test "create engine with custom config" {
    let config = Config.default().with_worker_pool_size(4);
    let app = Engine.new(config);
    assert_eq app.config.worker_pool_size, 4;
}

test "register GET route" {
    let app = Engine.default();
    app.get("/test", |ctx| {
        ctx.string("test");
    });

    // Router should have the route registered
    assert_eq app.router.routes.len(), 1;
}

test "register multiple routes" {
    let app = Engine.default();

    app.get("/", |ctx| { ctx.string("home"); });
    app.post("/users", |ctx| { ctx.string("create"); });
    app.put("/users/:id", |ctx| { ctx.string("update"); });

    assert_eq app.router.routes.len(), 3;
}

test "add middleware" {
    let app = Engine.default();

    app.use(|ctx| {
        try ctx.next();
    });

    app.use(|ctx| {
        try ctx.next();
    });

    assert_eq app.middleware.len(), 2;
}
