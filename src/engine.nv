/// Sake Engine - Main application entry point
///
/// Engine is the core of the Sake web framework. It manages routing,
/// middleware, and request handling with optional WorkerPool support.
///
/// # Example
/// ```nv
/// use sake.Engine;
///
/// fn main() throws {
///     let app = Engine.new();
///
///     app.get("/", |ctx| {
///         ctx.json({"message": "Hello, Sake!"});
///     });
///
///     app.get("/compute/:n", |ctx| {
///         let n = ctx.param("n") || "0";
///         let result = heavy_computation(n);
///         ctx.json({"result": result});
///     }).worker();  // Use WorkerPool for CPU-intensive task
///
///     try app.run(":8080");
/// }
/// ```

use std.net.{TcpListener, TcpStream};
use std.io;

use context.{Context, HandlerFunc};
use request.Request;
use response.Response;
use router.{Router, RouterGroup, RouteMatch};
use worker_pool.{WorkerPoolConfig, WorkerPoolRuntime};

/// Sake Engine configuration
pub struct EngineConfig {
    /// Address to bind to (e.g., ":8080", "127.0.0.1:3000")
    address: string,

    /// WorkerPool configuration (nil = no WorkerPool)
    worker_pool_config: WorkerPoolConfig?,
}

impl EngineConfig {
    /// Create default configuration
    pub fn default(): EngineConfig {
        return EngineConfig {
            address: ":8080",
            worker_pool_config: nil,
        };
    }

    /// Set the bind address
    pub fn with_address(self, address: string): EngineConfig {
        self.address = address;
        return self;
    }

    /// Enable WorkerPool with specified size
    pub fn with_workers(self, size: int): EngineConfig {
        self.worker_pool_config = WorkerPoolConfig.new(size);
        return self;
    }

    /// Set WorkerPool configuration
    pub fn with_worker_pool(self, config: WorkerPoolConfig): EngineConfig {
        self.worker_pool_config = config;
        return self;
    }
}

/// Sake Engine - Web application framework
pub struct Engine {
    /// Router for handling routes
    router: Router,

    /// WorkerPool configuration (stored as config, not runtime)
    worker_pool_config: WorkerPoolConfig?,
}

impl Engine {
    /// Create a new Sake Engine
    ///
    /// # Example
    /// ```nv
    /// let app = Engine.new();
    /// ```
    pub fn new(): Engine {
        return Engine {
            router: Router.new(),
            worker_pool_config: nil,
        };
    }

    /// Create Engine with WorkerPool support
    ///
    /// # Arguments
    /// * `worker_count` - Number of worker threads (0 = auto-detect)
    ///
    /// # Example
    /// ```nv
    /// let app = Engine.with_workers(4);
    /// ```
    pub fn with_workers(worker_count: int): Engine {
        return Engine {
            router: Router.new(),
            worker_pool_config: WorkerPoolConfig.new(worker_count),
        };
    }

    /// Configure WorkerPool
    ///
    /// # Arguments
    /// * `config` - WorkerPool configuration
    ///
    /// # Returns
    /// Self for chaining
    pub fn set_worker_pool(self, config: WorkerPoolConfig): Engine {
        self.worker_pool_config = config;
        return self;
    }

    // ============================================
    // Route registration (delegated to Router)
    // ============================================

    /// Register GET route
    pub fn get(self, pattern: string, handler: HandlerFunc): Route {
        return self.router.get(pattern, handler);
    }

    /// Register POST route
    pub fn post(self, pattern: string, handler: HandlerFunc): Route {
        return self.router.post(pattern, handler);
    }

    /// Register PUT route
    pub fn put(self, pattern: string, handler: HandlerFunc): Route {
        return self.router.put(pattern, handler);
    }

    /// Register DELETE route
    pub fn delete(self, pattern: string, handler: HandlerFunc): Route {
        return self.router.delete(pattern, handler);
    }

    /// Register PATCH route
    pub fn patch(self, pattern: string, handler: HandlerFunc): Route {
        return self.router.patch(pattern, handler);
    }

    /// Register HEAD route
    pub fn head(self, pattern: string, handler: HandlerFunc): Route {
        return self.router.head(pattern, handler);
    }

    /// Register OPTIONS route
    pub fn options(self, pattern: string, handler: HandlerFunc): Route {
        return self.router.options(pattern, handler);
    }

    /// Register route for any HTTP method
    pub fn any(self, pattern: string, handler: HandlerFunc) {
        self.router.any(pattern, handler);
    }

    /// Register route with custom HTTP method
    pub fn handle(self, method: string, pattern: string, handler: HandlerFunc): Route {
        return self.router.handle(method, pattern, handler);
    }

    /// Add global middleware
    pub fn use(self, middleware: HandlerFunc) {
        self.router.use(middleware);
    }

    /// Create a router group with the given prefix
    ///
    /// # Arguments
    /// * `prefix` - URL path prefix (e.g., "/api", "/v1")
    ///
    /// # Returns
    /// RouterGroup for method chaining
    ///
    /// # Example
    /// ```nv
    /// let app = Engine.new();
    /// let api = app.group("/api");
    /// api.get("/users", handler);  // Matches /api/users
    /// ```
    pub fn group(self, prefix: string): RouterGroup {
        return self.router.group(prefix);
    }

    // ============================================
    // Server execution
    // ============================================

    /// Start the HTTP server
    ///
    /// # Arguments
    /// * `address` - Address to bind to (e.g., ":8080")
    ///
    /// # Example
    /// ```nv
    /// try app.run(":8080");
    /// ```
    pub fn run(self, address: string) throws {
        let listener = try TcpListener.bind(address);
        let addr = try listener.local_addr();
        println(`üç∂ Sake server listening on ${addr}`);

        // Start WorkerPool if configured
        let pool_runtime: WorkerPoolRuntime? = nil;
        if (let config = self.worker_pool_config) {
            pool_runtime = try config.start();
            println(`   WorkerPool started with ${pool_runtime!.size()} workers`);
        }

        // Main server loop
        while (true) {
            let stream_result = try? listener.accept();
            if (stream_result == nil) {
                break;  // Shutdown signal
            }

            let stream = stream_result!;

            // Spawn concurrent task for each connection
            spawn {
                self.handle_connection(stream, pool_runtime) catch (e) {
                    eprintln(`Error handling connection: ${e.error()}`);
                };
            }
        }

        // Cleanup
        if (let pool = pool_runtime) {
            try pool.shutdown();
        }
    }

    /// Handle a single connection
    fn handle_connection(self, stream: TcpStream, pool_runtime: WorkerPoolRuntime?) throws {
        defer {
            try? stream.close();
        }

        // Read request
        let request_data = try self.read_request(stream);
        let request = try Request.parse(request_data);

        // Match route
        let route_match = self.router.match(request.method, request.path);

        if (route_match == nil) {
            // 404 Not Found
            let response = Response.not_found();
            try self.send_response(stream, response);
            return;
        }

        let matched = route_match!;

        // Check if route uses WorkerPool
        if (matched.route.use_worker_pool && pool_runtime != nil) {
            try self.handle_worker_route(stream, request, matched, pool_runtime!);
        } else {
            try self.handle_normal_route(stream, request, matched);
        }
    }

    /// Handle a normal route (using spawn)
    fn handle_normal_route(self, stream: TcpStream, request: Request, route_match: RouteMatch) throws {
        // Create context
        let handlers = self.router.get_handlers(route_match);
        let ctx = Context.with_handlers(request, handlers, route_match.params);

        // Execute handler chain
        ctx.next() catch (e) {
            eprintln(`Handler error: ${e.error()}`);
            ctx.abort_with_error(500, "Internal Server Error");
        };

        // Send response
        try self.send_response(stream, ctx.response);
    }

    /// Handle a WorkerPool route (CPU-intensive)
    fn handle_worker_route(
        self,
        stream: TcpStream,
        request: Request,
        route_match: RouteMatch,
        pool: WorkerPoolRuntime
    ) throws {
        // Serialize request context to JSON
        let task_json = self.serialize_request(request, route_match);

        // Submit to WorkerPool
        try pool.submit(task_json);

        // Get result
        let result_json = try pool.get_result();

        // Deserialize response
        let response = try self.deserialize_response(result_json);

        // Send response
        try self.send_response(stream, response);
    }

    /// Serialize request for WorkerPool
    fn serialize_request(self, request: Request, route_match: RouteMatch): string {
        // Simplified serialization (in real implementation, use proper JSON encoding)
        return `{
            "method": "${request.method}",
            "path": "${request.path}",
            "body": "${request.body}",
            "params": ${self.encode_params(route_match.params)}
        }`;
    }

    /// Encode params as JSON
    fn encode_params(self, params: <string, string>): string {
        if (params.len() == 0) {
            return "{}";
        }

        let parts: [string] = [];
        for (let key, value in params) {
            parts.push(`"${key}": "${value}"`);
        }

        return "{" + parts.join(", ") + "}";
    }

    /// Deserialize response from WorkerPool
    fn deserialize_response(self, json: string): Response throws {
        // Simplified deserialization (in real implementation, use proper JSON decoding)
        // For now, just return the JSON as the body
        let response = Response.new();
        response.content_type("application/json");
        response.write(json);
        return response;
    }

    /// Read request from stream
    fn read_request(self, stream: TcpStream): string throws {
        let buffer: [byte] = [];
        let chunk_size = 1024;

        // Read until we find "\r\n\r\n" (end of headers)
        while (true) {
            let chunk = try stream.read(chunk_size);
            if (chunk.len() == 0) {
                break;
            }

            buffer.extend(chunk);

            // Check if we have full headers
            let data = try String.from_utf8(buffer);
            if (data.contains("\r\n\r\n")) {
                // TODO: Read body based on Content-Length
                break;
            }
        }

        return try String.from_utf8(buffer);
    }

    /// Send response to stream
    fn send_response(self, stream: TcpStream, response: Response) throws {
        let data = response.build();
        try stream.write(data.as_bytes());
        try stream.flush();
    }
}

// ============================================
// Tests
// ============================================

test "create engine" {
    let app = Engine.new();
    assert app.worker_pool_config == nil;
}

test "create engine with workers" {
    let app = Engine.with_workers(4);
    assert app.worker_pool_config != nil;
    assert_eq app.worker_pool_config!.size, 4;
}

test "register routes" {
    let app = Engine.new();

    app.get("/", |ctx| {
        ctx.string("home");
    });

    app.post("/users", |ctx| {
        ctx.json({"message": "user created"});
    });

    assert_eq app.router.routes.len(), 2;
}

test "register worker route" {
    let app = Engine.new();

    app.get("/compute", |ctx| {
        ctx.string("computing");
    }).worker();

    let route_match = app.router.match("GET", "/compute");
    assert route_match != nil;
    assert_eq route_match!.route.use_worker_pool, true;
}

test "global middleware" {
    let app = Engine.new();

    let logger = |ctx: Context| {
        println("Request received");
        try ctx.next();
    };

    app.use(logger);

    assert_eq app.router.middleware.len(), 1;
}

test "serialize request" {
    let app = Engine.new();
    let req = try! Request.parse("GET /test HTTP/1.1\r\nHost: localhost\r\n\r\n");
    let params: <string, string> = {"id": "123"};

    let route = Route {
        method: "GET",
        pattern: "/test/:id",
        handler: |ctx| { ctx.string("test"); },
        middleware: [],
    };

    let route_match = RouteMatch {
        route,
        params,
    };

    let json = app.serialize_request(req, route_match);

    assert json.contains(`"method": "GET"`);
    assert json.contains(`"path": "/test"`);
    assert json.contains(`"id": "123"`);
}

test "engine router groups" {
    let app = Engine.new();
    let api = app.group("/api");

    api.get("/users", |ctx| {
        ctx.string("users");
    });

    let match_result = app.router.match("GET", "/api/users");
    assert match_result != nil;
    assert_eq match_result!.route.pattern, "/api/users";
}

test "engine nested groups" {
    let app = Engine.new();
    let api = app.group("/api");
    let v1 = api.group("/v1");

    v1.get("/users", |ctx| {
        ctx.string("v1 users");
    });

    let match_result = app.router.match("GET", "/api/v1/users");
    assert match_result != nil;
    assert_eq match_result!.route.pattern, "/api/v1/users";
}

test "engine group with middleware" {
    let app = Engine.new();

    let auth = |ctx: Context| {
        ctx.set("authenticated", true);
        try ctx.next();
    };

    let api = app.group("/api");
    api.use(auth);
    api.get("/protected", |ctx| {
        ctx.string("protected resource");
    });

    let match_result = app.router.match("GET", "/api/protected");
    assert match_result != nil;
    assert_eq match_result!.route.middleware.len(), 1;
}
