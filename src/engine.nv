/// Sake Web Framework Engine
///
/// Engine is the core of the Sake framework. It manages the HTTP server,
/// routing, middleware, and request handling with support for both
/// concurrent (spawn) and parallel (SakeWorkerPool) execution.
///
/// # Example
/// ```nv
/// use sake.Engine;
/// use sake.Config;
///
/// fn main() throws {
///     let config = Config.with_defaults();
///     let app = Engine.new(config);
///
///     app.get("/", |ctx| {
///         ctx.string("Hello!");
///     });
///
///     try app.run(":8080");
/// }
/// ```

use std.net.{TcpListener, Connection};
use std.io.{BufReader, Bytes};
use std.time;
// Note: config, router, context, request, response, worker_pool, worker_task, metrics are in same module

/// Sake web framework engine
pub struct Engine {
    /// Router for route matching
    router: Router,

    /// Configuration
    config: Config,

    /// Global middleware applied to all routes
    middleware: [Handler],

    /// Shutdown channel
    shutdown_ch: channel<bool>?,

    /// Worker pool for CPU-intensive routes
    worker_pool: SakeWorkerPool?,

    /// Worker task channel for coordinating spawn + WorkerPool
    /// Spawn sends tasks to main thread, which calls pool.map()
    worker_task_ch: channel<WorkerTask>?,

    /// Connection counter channel (send +1 to increment, -1 to decrement)
    conn_counter_ch: channel<int>?,

    /// Connection query channel (send unit, receive current count)
    conn_query_ch: channel<int>?,

    /// Performance metrics tracking
    metrics: Metrics,
}

impl Engine {
    /// Create a new Engine with given configuration
    ///
    /// # Arguments
    /// * `config` - Framework configuration
    ///
    /// # Returns
    /// New Engine instance
    pub fn new(config: Config): Engine {
        return Engine {
            router: Router.new(),
            config,
            middleware: [],
            shutdown_ch: nil,
            worker_pool: nil,
            worker_task_ch: nil,
            conn_counter_ch: nil,
            conn_query_ch: nil,
            metrics: Metrics.new(),
        };
    }

    /// Create a new Engine with default configuration
    pub fn with_defaults(): Engine {
        return Engine.new(Config.with_defaults());
    }

    /// Register a GET route
    ///
    /// # Arguments
    /// * `path` - Route path (supports :param syntax)
    /// * `handler` - Handler function
    ///
    /// # Returns
    /// RouteBuilder for further configuration (e.g., .worker())
    ///
    /// # Example
    /// ```nv
    /// app.get("/users/:id", |ctx| {
    ///     let id = ctx.param("id");
    ///     ctx.json({"id": id});
    /// });
    ///
    /// // For CPU-intensive routes:
    /// app.get("/compute/:n", |ctx| {
    ///     let result = expensive_computation();
    ///     ctx.json({"result": result});
    /// }).worker();
    /// ```
    pub fn get(self, path: string, handler: Handler): RouteBuilder {
        return self.router.add_route("GET", path, handler);
    }

    /// Register a POST route
    pub fn post(self, path: string, handler: Handler): RouteBuilder {
        return self.router.add_route("POST", path, handler);
    }

    /// Register a PUT route
    pub fn put(self, path: string, handler: Handler): RouteBuilder {
        return self.router.add_route("PUT", path, handler);
    }

    /// Register a DELETE route
    pub fn delete(self, path: string, handler: Handler): RouteBuilder {
        return self.router.add_route("DELETE", path, handler);
    }

    /// Register a PATCH route
    pub fn patch(self, path: string, handler: Handler): RouteBuilder {
        return self.router.add_route("PATCH", path, handler);
    }

    /// Register an OPTIONS route
    pub fn options(self, path: string, handler: Handler): RouteBuilder {
        return self.router.add_route("OPTIONS", path, handler);
    }

    /// Register a HEAD route
    pub fn head(self, path: string, handler: Handler): RouteBuilder {
        return self.router.add_route("HEAD", path, handler);
    }

    /// Register a route that matches ALL HTTP methods
    ///
    /// Registers the same handler for GET, POST, PUT, DELETE, PATCH, OPTIONS, and HEAD.
    ///
    /// # Arguments
    /// * `path` - Route path (supports :param and *wildcard syntax)
    /// * `handler` - Handler function
    ///
    /// # Example
    /// ```nv
    /// app.any("/ping", |ctx| {
    ///     ctx.json({"message": "pong"});
    /// });
    /// ```
    pub fn any(self, path: string, handler: Handler) {
        self.router.add_route("GET", path, handler);
        self.router.add_route("POST", path, handler);
        self.router.add_route("PUT", path, handler);
        self.router.add_route("DELETE", path, handler);
        self.router.add_route("PATCH", path, handler);
        self.router.add_route("OPTIONS", path, handler);
        self.router.add_route("HEAD", path, handler);
    }

    /// Add global middleware
    ///
    /// # Arguments
    /// * `middleware` - Middleware handler function
    ///
    /// # Example
    /// ```nv
    /// app.add_middleware(|ctx| {
    ///     println("Request received");
    ///     try ctx.next();
    /// });
    /// ```
    pub fn add_middleware(self, middleware: Handler) {
        self.middleware.push(middleware);
    }

    /// Create a route group with common path prefix
    ///
    /// RouterGroups allow organizing routes with common prefixes and middleware.
    ///
    /// # Arguments
    /// * `path` - Path prefix for all routes in this group
    ///
    /// # Returns
    /// RouterGroup instance for adding routes
    ///
    /// # Example
    /// ```nv
    /// // Create API v1 group
    /// let v1 = app.group("/api/v1");
    /// v1.add_middleware(auth_middleware);
    /// v1.get("/users", |ctx| {
    ///     ctx.json({"users": []});
    /// });
    ///
    /// // Create nested admin group
    /// let admin = v1.group("/admin");
    /// admin.get("/settings", |ctx| {
    ///     ctx.json({"settings": {}});
    /// });
    /// ```
    pub fn group(self, path: string): RouterGroup {
        return RouterGroup.new(self.router, path, []);
    }

    /// Start the HTTP server
    ///
    /// # Arguments
    /// * `addr` - Address to listen on (e.g., ":8080", "127.0.0.1:3000")
    ///
    /// # Errors
    /// Throws if server fails to start or encounters error during operation
    ///
    /// # Example
    /// ```nv
    /// try app.run(":8080");
    /// ```
    pub fn run(self, addr: string) throws {
        // Validate configuration
        try self.config.validate();

        // Log configuration
        println("üç∂ Sake Framework");
        println("==================");
        println(`Server address: ${addr}`);
        println(`Max connections: ${self.config.max_connections}`);
        println(`Request timeout: ${self.config.request_timeout}ms`);

        // Initialize shutdown channel
        let shutdown_ch = channel::<bool>();
        self.shutdown_ch = shutdown_ch;

        // Initialize SakeWorkerPool if enabled
        if (self.config.enable_worker_pool) {
            let pool_size = self.config.effective_worker_pool_size();
            println(`Worker pool: enabled (${pool_size} threads)`);
            self.worker_pool = try SakeWorkerPool.new(pool_size);

            // Initialize worker task channel for spawn-WorkerPool coordination
            // This prevents deadlock: spawn sends tasks, main thread calls pool.map()
            let worker_task_ch = channel::<WorkerTask>();
            self.worker_task_ch = worker_task_ch;
            println("Worker task channel: enabled (spawn-safe coordination)");
        } else {
            println("Worker pool: disabled");
        }

        // Start TCP listener
        let listener = try TcpListener.bind(addr);
        println("==================");
        println(`üç∂ Server ready at ${addr}`);

        // Architecture choice based on WorkerPool usage:
        // - With WorkerPool: Channel-based coordination (Option B)
        //   Accept in spawn, main thread processes WorkerPool tasks via channel
        //   This prevents deadlock (spawn + pool.map() blocks permanently)
        // - Without WorkerPool: Direct accept loop (Option A+)
        //   Main thread accepts, each connection in spawn, no blocking calls

        if (self.config.enable_worker_pool) {
            // WorkerPool enabled: Use channel-based coordination
            try self.run_with_worker_pool(listener);
        } else {
            // Spawn-only mode: Direct accept loop
            try self.run_spawn_only(listener);
        }

        println("üç∂ Sake server stopped");
    }

    /// Run server in spawn-only mode (no WorkerPool)
    /// Main thread accepts connections, each handled in spawn
    fn run_spawn_only(self, listener: TcpListener) throws {
        loop {
            // Check for shutdown signal (non-blocking)
            if (let ch = self.shutdown_ch) {
                if (let signal_opt = try? ch.try_recv()) {
                    if (let _ = signal_opt) {
                        println("üç∂ Sake server shutting down...");
                        break;
                    }
                }
            }

            // Accept connection (blocking)
            let stream_result = try? listener.accept();

            if (let stream = stream_result) {
                // Handle each connection in spawn
                spawn {
                    let stream = stream;

                    defer {
                        try? stream.close();
                    }

                    // Read and handle request
                    let raw_request_opt = try? self.read_http_request(stream);
                    if (let raw_request = raw_request_opt) {
                        if (raw_request.trim().len() == 0) {
                            return;
                        }

                        let request_opt = try? self.parse_request_or_error(raw_request);
                        if (let request = request_opt) {
                            let route_match = self.router.find_match(request.method, request.path);

                            if (let matched_route = route_match) {
                                try? self.handle_spawn_execution(stream, request, matched_route);
                            } else {
                                let response = Response.not_found();
                                let response_data = response.build();
                                let bytes = response_data.bytes();
                                try? stream.write_all(bytes);
                                try? stream.flush();
                            }
                        }
                    }
                }
            } else {
                break;
            }
        }
    }

    /// Run server with WorkerPool using channel-based coordination
    /// Accept loop in spawn, main thread processes WorkerPool tasks
    fn run_with_worker_pool(self, listener: TcpListener) throws {
        // Move accept to spawn so main thread can process WorkerPool tasks
        spawn {
            let listener = listener;
            let worker_task_ch = self.worker_task_ch;

            loop {
                let stream_result = try? listener.accept();

                if (let stream = stream_result) {
                    // Handle connection directly in first-level spawn
                    // (self is accessible here!)
                    try? self.handle_connection_worker_mode(stream, worker_task_ch);
                } else {
                    break;
                }
            }
        }

        // Main loop: process WorkerPool tasks
        while (true) {
            if (let ch = self.shutdown_ch) {
                if (let signal_opt = try? ch.try_recv()) {
                    if (let _ = signal_opt) {
                        println("üç∂ Sake server shutting down...");
                        break;
                    }
                }
            }

            if (let task_ch = self.worker_task_ch) {
                let task_opt = try? task_ch.recv();

                if (let task = task_opt) {
                    if (let pool = self.worker_pool) {
                        let response = try? pool.submit(task.ctx_json, task.handler_id);

                        if (let resp = response) {
                            try? task.response_ch.send(resp);
                        }
                    }
                }
            } else {
                break;
            }
        }
    }

    /// Handle connection in WorkerPool mode (called from first-level spawn)
    fn handle_connection_worker_mode(
        self,
        stream: Connection,
        worker_task_ch: channel<WorkerTask>?
    ) throws {
        defer {
            try? stream.close();
        }

        // Read and handle request
        let raw_request_opt = try? self.read_http_request(stream);
        if (let raw_request = raw_request_opt) {
            if (raw_request.trim().len() == 0) {
                return;
            }

            let request_opt = try? self.parse_request_or_error(raw_request);
            if (let request = request_opt) {
                let route_match = self.router.find_match(request.method, request.path);

                if (let matched_route = route_match) {
                    let use_worker = matched_route.route.worker_mode == WorkerMode.Worker;

                    if (use_worker) {
                        // WorkerPool route: use channel coordination
                        try? self.handle_worker_with_channel(
                            stream,
                            request,
                            matched_route,
                            worker_task_ch
                        );
                    } else {
                        // Spawn route: execute directly
                        try? self.handle_spawn_execution(stream, request, matched_route);
                    }
                } else {
                    let response = Response.not_found();
                    let response_data = response.build();
                    let bytes = response_data.bytes();
                    try? stream.write_all(bytes);
                    try? stream.flush();
                }
            }
        }
    }

    /// Handle a single client connection
    ///
    /// # Arguments
    /// * `stream` - TCP stream for the connection
    ///
    /// # Architecture Note
    /// This method is called directly from the accept loop (main thread).
    /// - WorkerPool routes: Execute synchronously in main thread (can block)
    /// - Spawn routes: Wrapped in spawn for concurrent execution
    fn handle_connection(self, stream: Connection) throws {
        // Read raw HTTP request
        let reader = BufReader.new(stream);
        let raw_request = try reader.read_to_string();

        // Parse HTTP request
        let request = try self.parse_request_or_error(raw_request);

        // Match route
        let route_match = self.router.find_match(request.method, request.path);

        if (let matched_route = route_match) {
            // Check if this route should use worker pool
            let has_worker_pool = false;
            if (let _ = self.worker_pool) {
                has_worker_pool = true;
            }

            let use_worker = matched_route.route.worker_mode == WorkerMode.Worker &&
                            self.config.enable_worker_pool &&
                            has_worker_pool;

            if (use_worker) {
                // Execute in worker pool (synchronous, main thread)
                // This will block the accept loop, but WorkerPool is for CPU-intensive
                // tasks that complete quickly in parallel worker threads
                defer {
                    try? stream.close();
                }

                // Track metrics
                let req_id = self.metrics.request_start();
                defer {
                    self.metrics.request_end(req_id);
                }

                try self.handle_worker_execution(stream, request, matched_route);
            } else {
                // Execute with spawn (concurrent, non-blocking)
                // Spawn allows the accept loop to continue processing new connections
                spawn {
                    // Capture variables for spawn context
                    let stream = stream;
                    let request = request;
                    let matched_route = matched_route;
                    let metrics = self.metrics;

                    defer {
                        try? stream.close();
                    }

                    // Track metrics
                    let req_id = metrics.request_start();
                    defer {
                        metrics.request_end(req_id);
                    }

                    try? self.handle_spawn_execution(stream, request, matched_route);
                }
            }
        } else {
            // No route found - send 404
            defer {
                try? stream.close();
            }

            let response = Response.not_found();
            try response.send(stream);
        }
    }

    /// Handle connection with channel-based WorkerPool coordination
    ///
    /// # Arguments
    /// * `stream` - TCP stream for the connection
    /// * `worker_task_ch` - Channel to send WorkerPool tasks to main thread
    ///
    /// # Architecture
    /// This method runs in spawn and safely coordinates with WorkerPool:
    /// 1. Read and parse request (in spawn)
    /// 2. Match route
    /// 3. If WorkerPool route:
    ///    - Create response channel
    ///    - Send task to main thread via worker_task_ch
    ///    - Wait for response (channel.recv() yields in spawn)
    /// 4. If Spawn route:
    ///    - Execute directly in current spawn
    fn handle_connection_with_channel(
        self,
        stream: Connection,
        worker_task_ch: channel<WorkerTask>?
    ) throws {
        println("üü£ handle_connection_with_channel: ‚úÖ ENTRY");
        defer {
            println("üü£ handle_connection_with_channel: üîí defer: closing stream");
            try? stream.close();
            println("üü£ handle_connection_with_channel: üîí defer: stream closed");
        }

        // Read raw HTTP request (correctly, not waiting for EOF)
        println("üü£ Step 1: Reading HTTP request");
        let raw_request = try self.read_http_request(stream);
        println(`üü£ Step 2: ‚úÖ Read ${raw_request.len()} bytes`);

        // Parse HTTP request
        println("üü£ Step 4: Parsing request");
        let request = try self.parse_request_or_error(raw_request);
        println(`üü£ Step 5: ‚úÖ Parsed: ${request.method} ${request.path}`);

        // Match route
        println("üü£ Step 6: Matching route");
        let route_match = self.router.find_match(request.method, request.path);
        println("üü£ Step 7: ‚úÖ Route match completed");

        if (let matched_route = route_match) {
            println("üü£ Step 8: ‚úÖ Route matched!");

            // Check if this route should use worker pool
            let has_worker_pool = false;
            if (let _ = self.worker_pool) {
                has_worker_pool = true;
                println("üü£ Step 9: WorkerPool available");
            } else {
                println("üü£ Step 9: No WorkerPool");
            }

            let use_worker = matched_route.route.worker_mode == WorkerMode.Worker &&
                            self.config.enable_worker_pool &&
                            has_worker_pool;

            if (use_worker) {
                println("üü¢ Step 10: ‚úÖ Using WorkerPool mode (via channel)");

                // Serialize context for worker
                println("üü¢ Step 11: Creating context");
                let ctx = Context.with_handlers(request, [], matched_route.params);
                ctx.in_worker = true;
                ctx.worker_size = self.config.effective_worker_pool_size();
                ctx.handler_id = matched_route.route.handler_id;

                println("üü¢ Step 12: Serializing to JSON");
                let worker_ctx = ctx.to_worker_context();
                // Copy frozen bindings from route to worker context
                for (let name, data in matched_route.route.frozen_bindings) {
                    worker_ctx.frozen_data[name] = data;
                }
                let ctx_json = try worker_ctx.to_json();
                println(`üü¢ Step 13: JSON serialized (${ctx_json.len()} bytes)`);

                // Create response channel
                println("üü¢ Step 14: Creating response channel");
                let response_ch = channel::<WorkerResponse>();

                // Create worker task
                println("üü¢ Step 15: Creating WorkerTask");
                let task = WorkerTask.new(ctx_json, 0, response_ch);

                // Send task to main thread
                if (let task_ch = worker_task_ch) {
                    println("üü¢ Step 16: Sending task to main thread via channel");
                    try task_ch.send(task);
                    println("üü¢ Step 17: ‚úÖ Task sent! Now waiting for response...");

                    // Wait for response (recv() yields in spawn, allowing main thread to process)
                    println("üü¢ Step 18: Calling response_ch.recv() - WILL BLOCK");
                    let worker_response = try response_ch.recv();
                    println("üü¢ Step 19: ‚úÖ Received response from WorkerPool!");

                    // Build and send HTTP response
                    println("üü¢ Step 20: Building HTTP response");
                    let response = Response.new();
                    response.status(worker_response.status);

                    for (let name, value in worker_response.headers) {
                        response.header(name, value);
                    }

                    response.write(worker_response.body);

                    println("üü¢ Step 21: Sending HTTP response to client");
                    let response_data = response.build();
                    println(`üü¢ Step 21a: Response built, ${response_data.len()} bytes`);

                    // Use bytes write_all to workaround stdlib write_string bug
                    println("üü¢ Step 21b: Converting to bytes");
                    let bytes = response_data.bytes();
                    println(`üü¢ Step 21c: Got ${bytes.len()} bytes, writing...`);
                    try stream.write_all(bytes);
                    println("üü¢ Step 21d: Flushing stream");
                    try stream.flush();
                    println("üü¢ Step 22: ‚úÖ Response sent!");
                } else {
                    println("üî¥ ERROR: Worker task channel not initialized!");
                    throw "Worker task channel not initialized";
                }
            } else {
                // Spawn route: execute directly
                println("üü° Step 10: Using spawn execution (not WorkerPool)");
                try self.handle_spawn_execution(stream, request, matched_route);
                println("üü° Step 11: ‚úÖ Spawn execution completed");
            }
        } else {
            println("üü£ Step 8: ‚ùå No route matched - sending 404");
            let response = Response.not_found();
            try response.send(stream);
            println("üü£ Step 9: 404 sent");
        }
    }

    /// Handle request execution in spawn mode (concurrent, single-threaded)
    ///
    /// Builds the complete handler chain:
    /// 1. Global middleware (from app.add_middleware())
    /// 2. Group middleware (from group.add_middleware())
    /// 3. Route middleware (from route.add_middleware())
    /// 4. Route handler
    ///
    /// # Arguments
    /// * `stream` - TCP stream
    /// * `request` - Parsed HTTP request
    /// * `route_match` - Matched route with parameters
    fn handle_spawn_execution(
        self,
        stream: Connection,
        request: Request,
        route_match: RouteMatch
    ) throws {
        // Track metrics
        let req_id = self.metrics.request_start();
        defer {
            self.metrics.request_end(req_id);
        }

        // Build handler chain: global middleware + route middleware + handler
        let handlers: [Handler] = [];

        // 1. Add global middleware
        for (let mw in self.middleware) {
            handlers.push(mw);
        }

        // 2. Add route-specific middleware (includes group middleware if from group)
        for (let mw in route_match.route.middleware) {
            handlers.push(mw);
        }

        // 3. Add route handler
        handlers.push(route_match.route.handler);

        // Create context
        let ctx = Context.with_handlers(request, handlers, route_match.params);

        // Execute handler chain
        try ctx.next();

        // Send response using bytes workaround for stdlib bug
        let response_data = ctx.response.build();
        let bytes = response_data.bytes();
        try stream.write_all(bytes);
        try stream.flush();
    }

    /// Handle request execution in worker pool mode (parallel, multi-threaded)
    ///
    /// # Arguments
    /// * `stream` - TCP stream
    /// * `request` - Parsed HTTP request
    /// * `route_match` - Matched route with parameters
    fn handle_worker_execution(
        self,
        stream: Connection,
        request: Request,
        route_match: RouteMatch
    ) throws {
        // Serialize context for worker
        let ctx = Context.with_handlers(request, [], route_match.params);
        ctx.in_worker = true;
        ctx.worker_size = self.config.effective_worker_pool_size();
        ctx.handler_id = route_match.route.handler_id;

        let worker_ctx = ctx.to_worker_context();
        // Copy frozen bindings from route to worker context
        for (let name, data in route_match.route.frozen_bindings) {
            worker_ctx.frozen_data[name] = data;
        }
        let ctx_json = try worker_ctx.to_json();

        // Submit to worker pool
        if (let pool = self.worker_pool) {
            let worker_response = try pool.submit(ctx_json, 0);

            // Build response from worker result
            let response = Response.new();
            response.status(worker_response.status);

            for (let name, value in worker_response.headers) {
                response.header(name, value);
            }

            response.write(worker_response.body);

            // Send response
            try response.send(stream);
        } else {
            throw "Worker pool not initialized";
        }
    }

    /// Handle WorkerPool execution using channel-based coordination
    ///
    /// This method runs in spawn and coordinates with main thread via channel:
    /// 1. Serialize context to JSON
    /// 2. Create response channel
    /// 3. Send task to main thread via worker_task_ch
    /// 4. Wait for response (channel.recv() yields, doesn't block)
    /// 5. Send HTTP response to client
    ///
    /// # Arguments
    /// * `stream` - TCP stream
    /// * `request` - Parsed HTTP request
    /// * `route_match` - Matched route with parameters
    /// * `worker_task_ch` - Channel to send tasks to main thread
    fn handle_worker_with_channel(
        self,
        stream: Connection,
        request: Request,
        route_match: RouteMatch,
        worker_task_ch: channel<WorkerTask>?
    ) throws {
        // Track metrics
        let req_id = self.metrics.request_start();
        defer {
            self.metrics.request_end(req_id);
        }

        // Serialize context for worker
        let ctx = Context.with_handlers(request, [], route_match.params);
        ctx.in_worker = true;
        ctx.worker_size = self.config.effective_worker_pool_size();
        ctx.handler_id = route_match.route.handler_id;

        let worker_ctx = ctx.to_worker_context();
        // Copy frozen bindings from route to worker context
        for (let name, data in route_match.route.frozen_bindings) {
            worker_ctx.frozen_data[name] = data;
        }
        let ctx_json = try worker_ctx.to_json();

        // Create response channel
        let response_ch = channel::<WorkerResponse>();

        // Create and send task to main thread
        if (let task_ch = worker_task_ch) {
            let task = WorkerTask.new(ctx_json, route_match.route.handler_id, response_ch);
            try task_ch.send(task);

            // Wait for response (recv() yields in spawn, allowing other tasks to run)
            let worker_response = try response_ch.recv();

            // Build and send HTTP response
            let response = Response.new();
            response.status(worker_response.status);

            for (let name, value in worker_response.headers) {
                response.header(name, value);
            }

            response.write(worker_response.body);

            // Send using bytes workaround
            let response_data = response.build();
            let bytes = response_data.bytes();
            try stream.write_all(bytes);
            try stream.flush();
        } else {
            throw "Worker task channel not initialized";
        }
    }

    /// Read HTTP request from connection stream
    ///
    /// Reads until \r\n\r\n (end of headers), then reads body if Content-Length present.
    /// Does NOT wait for EOF like read_to_string().
    ///
    /// # Arguments
    /// * `stream` - Connection stream
    ///
    /// # Returns
    /// Complete HTTP request string
    fn read_http_request(self, stream: Connection): string throws {
        let reader = BufReader.new(stream);
        let lines: [string] = [];
        let headers_complete = false;

        // Read headers line by line until empty line
        while (!headers_complete) {
            let line_opt = try? reader.read_line();
            if (let line = line_opt) {
                // Check for end of headers (empty line or \r\n)
                let trimmed = line.trim();
                if (trimmed.len() == 0) {
                    headers_complete = true;
                    lines.push("");  // Keep the empty line
                } else {
                    lines.push(line);
                }
            } else {
                headers_complete = true;
                break;
            }
        }

        // TODO: Handle request body for POST/PUT
        // For now, we only support GET requests (no body)

        let result = lines.join("\r\n");
        return result;
    }

    /// Parse request or return error response
    ///
    /// # Arguments
    /// * `raw` - Raw HTTP request string
    ///
    /// # Returns
    /// Parsed Request or throws on error
    fn parse_request_or_error(self, raw: string): Request throws {
        do {
            let request = try Request.parse(raw);
            return request;
        } catch (e) {
            // Log parse error
            println(`Error parsing request: ${e.error()}`);
            throw "Malformed request";
        }
    }

    /// Shutdown the server gracefully
    ///
    /// Signals the server to stop accepting new connections
    /// and wait for existing requests to complete.
    pub fn shutdown(self) throws {
        if (let ch = self.shutdown_ch) {
            try ch.send(true);
        }

        // Shutdown worker pool if initialized
        if (let pool = self.worker_pool) {
            pool.shutdown();
        }
    }
}

// ============================================
// Tests
// ============================================

test "create engine with default config" {
    let app = Engine.with_defaults();
    assert_eq app.config.worker_pool_size, 0;
    assert_eq app.config.enable_worker_pool, true;
}

test "create engine with custom config" {
    let config = Config.with_defaults().with_worker_pool_size(4);
    let app = Engine.new(config);
    assert_eq app.config.worker_pool_size, 4;
}

test "register GET route" {
    let app = Engine.with_defaults();
    app.get("/", func_handler(|ctx| {
        ctx.string("Hello");
    }));
    assert_eq app.router.routes.len(), 1;
}

test "register multiple routes" {
    let app = Engine.with_defaults();
    app.get("/", func_handler(|ctx| { ctx.string("Home"); }));
    app.post("/users", func_handler(|ctx| { ctx.string("Create"); }));
    app.put("/users/:id", func_handler(|ctx| { ctx.string("Update"); }));
    assert_eq app.router.routes.len(), 3;
}

test "add middleware" {
    let app = Engine.with_defaults();
    app.add_middleware(func_handler(|ctx| {
        try ctx.next();
    }));
    assert_eq app.middleware.len(), 1;
}

test "register OPTIONS route" {
    let app = Engine.with_defaults();
    app.options("/", func_handler(|ctx| { ctx.string("OPTIONS"); }));
    assert_eq app.router.routes.len(), 1;
}

test "register HEAD route" {
    let app = Engine.with_defaults();
    app.head("/", func_handler(|ctx| { ctx.string("HEAD"); }));
    assert_eq app.router.routes.len(), 1;
}

test "register ANY route" {
    let app = Engine.with_defaults();
    app.any("/", func_handler(|ctx| { ctx.string("ANY"); }));
    assert_eq app.router.routes.len(), 7;  // GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD
}
