/// Sake Web Framework Engine
///
/// Engine is the core of the Sake framework. It manages the HTTP server,
/// routing, middleware, and request handling with support for both
/// concurrent (spawn) and parallel (WorkerPool) execution.
///
/// # Example
/// ```nv
/// use sake.Engine;
/// use sake.Config;
///
/// fn main() throws {
///     let config = Config.default();
///     let app = Engine.new(config);
///
///     app.get("/", |ctx| {
///         ctx.string("Hello!");
///     });
///
///     try app.run(":8080");
/// }
/// ```

use std.net.{TcpListener, TcpStream};
use std.io.{BufReader};
use config.Config;
use router.{Router, RouteBuilder, WorkerMode, RouteMatch};
use context.{Context, HandlerFunc};
use request.Request;
use response.Response;
use worker_pool.WorkerPool;

/// Sake web framework engine
pub struct Engine {
    /// Router for route matching
    router: Router,

    /// Configuration
    config: Config,

    /// Global middleware applied to all routes
    middleware: [HandlerFunc],

    /// Shutdown channel
    shutdown_ch: channel::<bool>?,

    /// Worker pool for CPU-intensive routes
    worker_pool: WorkerPool?,

    /// Current active connection count
    active_connections: int = 0,
}

impl Engine {
    /// Create a new Engine with given configuration
    ///
    /// # Arguments
    /// * `config` - Framework configuration
    ///
    /// # Returns
    /// New Engine instance
    pub fn new(config: Config): Engine {
        return Engine {
            router: Router.new(),
            config,
            middleware: [],
            shutdown_ch: nil,
            worker_pool: nil,
        };
    }

    /// Create a new Engine with default configuration
    pub fn default(): Engine {
        return Engine.new(Config.default());
    }

    /// Register a GET route
    ///
    /// # Arguments
    /// * `path` - Route path (supports :param syntax)
    /// * `handler` - Handler function
    ///
    /// # Returns
    /// RouteBuilder for further configuration (e.g., .worker())
    ///
    /// # Example
    /// ```nv
    /// app.get("/users/:id", |ctx| {
    ///     let id = ctx.param("id");
    ///     ctx.json({"id": id});
    /// });
    ///
    /// // For CPU-intensive routes:
    /// app.get("/compute/:n", |ctx| {
    ///     let result = expensive_computation();
    ///     ctx.json({"result": result});
    /// }).worker();
    /// ```
    pub fn get(self, path: string, handler: HandlerFunc): RouteBuilder {
        return self.router.add_route("GET", path, handler);
    }

    /// Register a POST route
    pub fn post(self, path: string, handler: HandlerFunc): RouteBuilder {
        return self.router.add_route("POST", path, handler);
    }

    /// Register a PUT route
    pub fn put(self, path: string, handler: HandlerFunc): RouteBuilder {
        return self.router.add_route("PUT", path, handler);
    }

    /// Register a DELETE route
    pub fn delete(self, path: string, handler: HandlerFunc): RouteBuilder {
        return self.router.add_route("DELETE", path, handler);
    }

    /// Register a PATCH route
    pub fn patch(self, path: string, handler: HandlerFunc): RouteBuilder {
        return self.router.add_route("PATCH", path, handler);
    }

    /// Add global middleware
    ///
    /// # Arguments
    /// * `middleware` - Middleware handler function
    ///
    /// # Example
    /// ```nv
    /// app.use(|ctx| {
    ///     println("Request received");
    ///     try ctx.next();
    /// });
    /// ```
    pub fn use(self, middleware: HandlerFunc) {
        self.middleware.push(middleware);
    }

    /// Start the HTTP server
    ///
    /// # Arguments
    /// * `addr` - Address to listen on (e.g., ":8080", "127.0.0.1:3000")
    ///
    /// # Errors
    /// Throws if server fails to start or encounters error during operation
    ///
    /// # Example
    /// ```nv
    /// try app.run(":8080");
    /// ```
    pub fn run(self, addr: string) throws {
        // Validate configuration
        try self.config.validate();

        // Log configuration
        println("üç∂ Sake Framework");
        println("==================");
        println(`Server address: ${addr}`);
        println(`Max connections: ${self.config.max_connections}`);
        println(`Request timeout: ${self.config.request_timeout}ms`);

        // Initialize shutdown channel
        let shutdown_ch = channel::<bool>();
        self.shutdown_ch = shutdown_ch;

        // Initialize WorkerPool if enabled
        if (self.config.enable_worker_pool) {
            let pool_size = self.config.effective_worker_pool_size();
            println(`Worker pool: enabled (${pool_size} threads)`);
            self.worker_pool = try WorkerPool.new(pool_size);
        } else {
            println("Worker pool: disabled (spawn mode only)");
        }

        // Start TCP listener
        let listener = try TcpListener.bind(addr);
        println("==================");
        println(`üç∂ Server ready at ${addr}`);

        // Accept connections loop
        while (true) {
            // Check for shutdown signal (non-blocking)
            if (let ch = self.shutdown_ch) {
                let should_stop = try? ch.try_recv();
                if (should_stop != nil) {
                    println("üç∂ Sake server shutting down...");
                    break;
                }
            }

            // Check max connections limit
            if (self.active_connections >= self.config.max_connections) {
                // Connection limit reached - wait before accepting more
                // TODO: Implement proper connection queueing
                continue;
            }

            // Accept next connection
            let stream_result = try? listener.accept();
            if (let stream = stream_result) {
                // Track active connections
                self.active_connections += 1;

                // Spawn handler for this connection
                spawn {
                    defer {
                        self.active_connections -= 1;
                    }
                    try? self.handle_connection(stream);
                }
            }
        }

        println("üç∂ Sake server stopped");
    }

    /// Handle a single client connection
    ///
    /// # Arguments
    /// * `stream` - TCP stream for the connection
    fn handle_connection(self, stream: TcpStream) throws {
        defer {
            stream.close();
        }

        // Read request with timeout
        // TODO: Apply request_timeout from config

        // Read raw HTTP request
        let reader = BufReader.new(stream);
        let raw_request = try reader.read_to_string();

        // Parse HTTP request
        let request = try self.parse_request_or_error(raw_request);

        // Match route
        let route_match = self.router.match(request.method, request.path);

        if (let match = route_match) {
            // Check if this route should use worker pool
            let use_worker = match.route.worker_mode == WorkerMode.Worker &&
                            self.config.enable_worker_pool &&
                            self.worker_pool != nil;

            if (use_worker) {
                // Execute in worker pool
                try self.handle_worker_execution(stream, request, match);
            } else {
                // Execute with spawn (default)
                try self.handle_spawn_execution(stream, request, match);
            }
        } else {
            // No route found - send 404
            let response = Response.not_found();
            try response.send(stream);
        }
    }

    /// Handle request execution in spawn mode (concurrent, single-threaded)
    ///
    /// # Arguments
    /// * `stream` - TCP stream
    /// * `request` - Parsed HTTP request
    /// * `route_match` - Matched route with parameters
    fn handle_spawn_execution(
        self,
        stream: TcpStream,
        request: Request,
        route_match: RouteMatch
    ) throws {
        // Build handler chain: global middleware + route handler
        let handlers: [HandlerFunc] = [];

        // Add global middleware
        for (let mw in self.middleware) {
            handlers.push(mw);
        }

        // Add route handler
        handlers.push(route_match.route.handler);

        // Create context
        let ctx = Context.with_handlers(request, handlers, route_match.params);

        // Execute handler chain
        try ctx.next();

        // Send response
        try ctx.response.send(stream);
    }

    /// Handle request execution in worker pool mode (parallel, multi-threaded)
    ///
    /// # Arguments
    /// * `stream` - TCP stream
    /// * `request` - Parsed HTTP request
    /// * `route_match` - Matched route with parameters
    fn handle_worker_execution(
        self,
        stream: TcpStream,
        request: Request,
        route_match: RouteMatch
    ) throws {
        // Serialize context for worker
        let ctx = Context.with_handlers(request, [], route_match.params);
        ctx.in_worker = true;
        ctx.worker_size = self.config.effective_worker_pool_size();

        let worker_ctx = ctx.to_worker_context();
        let ctx_json = try worker_ctx.to_json();

        // Submit to worker pool
        if (let pool = self.worker_pool) {
            let worker_response = try pool.submit(ctx_json, 0);

            // Build response from worker result
            let response = Response.new();
            response.status(worker_response.status);

            for (let name, value in worker_response.headers) {
                response.header(name, value);
            }

            response.write(worker_response.body);

            // Send response
            try response.send(stream);
        } else {
            throw "Worker pool not initialized";
        }
    }

    /// Parse request or return error response
    ///
    /// # Arguments
    /// * `raw` - Raw HTTP request string
    ///
    /// # Returns
    /// Parsed Request or throws on error
    fn parse_request_or_error(self, raw: string): Request throws {
        do {
            let request = try Request.parse(raw);
            return request;
        } catch (e) {
            // Log parse error
            println(`Error parsing request: ${e.error()}`);
            throw "Malformed request";
        }
    }

    /// Shutdown the server gracefully
    ///
    /// Signals the server to stop accepting new connections
    /// and wait for existing requests to complete.
    pub fn shutdown(self) throws {
        if (let ch = self.shutdown_ch) {
            try ch.send(true);
        }

        // Shutdown worker pool if initialized
        if (let pool = self.worker_pool) {
            try pool.shutdown();
        }
    }
}

// ============================================
// Tests
// ============================================

test "create engine with default config" {
    let app = Engine.default();
    assert_eq app.config.worker_pool_size, 0;
    assert_eq app.config.enable_worker_pool, true;
}

test "create engine with custom config" {
    let config = Config.default().with_worker_pool_size(4);
    let app = Engine.new(config);
    assert_eq app.config.worker_pool_size, 4;
}

test "register GET route" {
    let app = Engine.default();
    app.get("/test", |ctx| {
        ctx.string("test");
    });

    // Router should have the route registered
    assert_eq app.router.routes.len(), 1;
}

test "register multiple routes" {
    let app = Engine.default();

    app.get("/", |ctx| { ctx.string("home"); });
    app.post("/users", |ctx| { ctx.string("create"); });
    app.put("/users/:id", |ctx| { ctx.string("update"); });

    assert_eq app.router.routes.len(), 3;
}

test "add middleware" {
    let app = Engine.default();

    app.use(|ctx| {
        try ctx.next();
    });

    app.use(|ctx| {
        try ctx.next();
    });

    assert_eq app.middleware.len(), 2;
}
