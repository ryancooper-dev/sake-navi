/// Serializable request context for WorkerPool
///
/// WorkerContext is a serializable version of Context that can be
/// sent across thread boundaries to worker threads. It contains only
/// the essential request data without closures or non-serializable types.

use std.json;
use std.sync.freeze;

/// Serializable request context for worker threads
pub struct WorkerContext {
    /// Request path
    pub path: string,

    /// HTTP method
    pub method: string,

    /// Request headers
    pub headers: <string, string>,

    /// Query parameters
    pub query: <string, string>,

    /// Path parameters (from route matching)
    pub params: <string, string>,

    /// Request body
    pub body: string,

    /// Handler ID for registered worker handlers
    /// This is used by REGISTRY.call() to invoke the correct handler
    pub handler_id: int = -1,

    /// Frozen data bindings (name -> JSON-serialized Frozen bytes)
    /// Used to pass immutable data from main thread to worker threads
    pub frozen_data: <string, string> = {:},
}

impl WorkerContext {
    /// Create a new WorkerContext
    pub fn new(
        path: string,
        method: string,
        headers: <string, string>,
        query: <string, string>,
        params: <string, string>,
        body: string
    ): WorkerContext {
        return WorkerContext {
            path,
            method,
            headers,
            query,
            params,
            body,
            handler_id: -1,
            frozen_data: {:},
        };
    }

    /// Create a new WorkerContext with handler_id
    pub fn with_handler_id(
        path: string,
        method: string,
        headers: <string, string>,
        query: <string, string>,
        params: <string, string>,
        body: string,
        handler_id: int
    ): WorkerContext {
        return WorkerContext {
            path,
            method,
            headers,
            query,
            params,
            body,
            handler_id,
            frozen_data: {:},
        };
    }

    /// Get a frozen value by name
    ///
    /// Retrieves a Frozen<T> value that was attached to the route
    /// via RouteBuilder.with_frozen(). The type T must match the
    /// type used when the frozen value was created.
    ///
    /// # Arguments
    /// * `name` - Name of the frozen value (as specified in with_frozen())
    ///
    /// # Returns
    /// The Frozen<T> value
    ///
    /// # Errors
    /// Throws if the name is not found or deserialization fails
    ///
    /// # Example
    /// ```nv
    /// fn my_handler(ctx: WorkerContext): WorkerResponse throws {
    ///     let config = try ctx.frozen::<Config>("config");
    ///     let value = try config.get();
    ///     return WorkerResponse.json(200, `{"timeout": ${value.timeout}}`);
    /// }
    /// ```
    pub fn frozen<T>(self, name: string): Frozen<T> throws {
        let data = self.frozen_data.get(name);
        if (data == nil) {
            throw `Frozen data not found: ${name}`;
        }
        // Deserialize the JSON-encoded Frozen<T> back to Frozen<T>
        return try json.parse::<Frozen<T>>(data!);
    }

    /// Serialize to JSON string
    ///
    /// # Returns
    /// JSON string representation
    ///
    /// # Errors
    /// Throws if JSON encoding fails
    pub fn to_json(self): string throws {
        // Use json.to_string to serialize the WorkerContext struct
        return try json.to_string(self);
    }

    /// Deserialize from JSON string
    ///
    /// # Arguments
    /// * `json_str` - JSON string to parse
    ///
    /// # Returns
    /// WorkerContext instance
    ///
    /// # Errors
    /// Throws if JSON is invalid or missing required fields
    pub fn from_json(json_str: string): WorkerContext throws {
        // Use json.parse to deserialize directly to WorkerContext
        return try json.parse::<WorkerContext>(json_str);
    }
}

/// Serializable response from worker threads
pub struct WorkerResponse {
    /// HTTP status code
    pub status: int,

    /// Response headers
    pub headers: <string, string>,

    /// Response body
    pub body: string,
}

impl WorkerResponse {
    /// Create a new WorkerResponse
    pub fn new(status: int, headers: <string, string>, body: string): WorkerResponse {
        return WorkerResponse {
            status,
            headers,
            body,
        };
    }

    /// Create a successful JSON response
    pub fn json(status: int, body: string): WorkerResponse {
        let headers: <string, string> = {
            "Content-Type": "application/json; charset=utf-8",
        };
        return WorkerResponse {
            status,
            headers,
            body,
        };
    }

    /// Create a plain text response
    pub fn text(status: int, body: string): WorkerResponse {
        let headers: <string, string> = {
            "Content-Type": "text/plain; charset=utf-8",
        };
        return WorkerResponse {
            status,
            headers,
            body,
        };
    }

    /// Serialize to JSON string
    ///
    /// # Returns
    /// JSON string representation
    ///
    /// # Errors
    /// Throws if JSON encoding fails
    pub fn to_json(self): string throws {
        // Use json.to_string to serialize the WorkerResponse struct
        return try json.to_string(self);
    }

    /// Deserialize from JSON string
    ///
    /// # Arguments
    /// * `json_str` - JSON string to parse
    ///
    /// # Returns
    /// WorkerResponse instance
    ///
    /// # Errors
    /// Throws if JSON is invalid or missing required fields
    pub fn from_json(json_str: string): WorkerResponse throws {
        // Use json.parse to deserialize directly to WorkerResponse
        return try json.parse::<WorkerResponse>(json_str);
    }
}

// ============================================
// Tests
// ============================================

test "create worker context" {
    let headers: <string, string> = {"host": "localhost"};
    let query: <string, string> = {"page": "1"};
    let params: <string, string> = {"id": "123"};

    let ctx = WorkerContext.new(
        "/users/123",
        "GET",
        headers,
        query,
        params,
        ""
    );

    assert_eq ctx.path, "/users/123";
    assert_eq ctx.method, "GET";
    assert_eq ctx.params.get("id"), "123";
}

test "serialize worker context to json" {
    let headers: <string, string> = {"host": "localhost"};
    let query: <string, string> = {"page": "1"};
    let params: <string, string> = {"id": "123"};

    let ctx = WorkerContext.new(
        "/users/123",
        "GET",
        headers,
        query,
        params,
        "body content"
    );

    let json_str = try! ctx.to_json();

    assert json_str.len() > 0;
    assert json_str.contains("\"path\"");
    assert json_str.contains("\"method\"");
    assert json_str.contains("/users/123");
}

test "deserialize worker context from json" {
    let json_str = "{\"path\":\"/test\",\"method\":\"POST\",\"headers\":{\"host\":\"localhost\"},\"query\":{},\"params\":{\"id\":\"1\"},\"body\":\"test\"}";

    let ctx = try! WorkerContext.from_json(json_str);

    assert_eq ctx.path, "/test";
    assert_eq ctx.method, "POST";
    assert_eq ctx.headers.get("host"), "localhost";
    assert_eq ctx.params.get("id"), "1";
    assert_eq ctx.body, "test";
}

test "worker context roundtrip serialization" {
    let headers: <string, string> = {"content-type": "application/json"};
    let query: <string, string> = {"filter": "active"};
    let params: <string, string> = {"userId": "42"};

    let original = WorkerContext.new(
        "/api/users/42",
        "PUT",
        headers,
        query,
        params,
        "{\"name\":\"John\"}"
    );

    let json_str = try! original.to_json();
    let restored = try! WorkerContext.from_json(json_str);

    assert_eq restored.path, original.path;
    assert_eq restored.method, original.method;
    assert_eq restored.body, original.body;
    assert_eq restored.params.get("userId"), "42";
}

test "create worker response" {
    let headers: <string, string> = {"Content-Type": "text/plain"};
    let resp = WorkerResponse.new(200, headers, "OK");

    assert_eq resp.status, 200;
    assert_eq resp.body, "OK";
}

test "worker response json helper" {
    let resp = WorkerResponse.json(200, "{\"ok\": true}");

    assert_eq resp.status, 200;
    assert_eq resp.headers.get("Content-Type"), "application/json; charset=utf-8";
    assert_eq resp.body, "{\"ok\": true}";
}

test "worker response text helper" {
    let resp = WorkerResponse.text(404, "Not Found");

    assert_eq resp.status, 404;
    assert_eq resp.headers.get("Content-Type"), "text/plain; charset=utf-8";
    assert_eq resp.body, "Not Found";
}

test "serialize worker response to json" {
    let headers: <string, string> = {"X-Custom": "value"};
    let resp = WorkerResponse.new(201, headers, "Created");

    let json_str = try! resp.to_json();

    assert json_str.len() > 0;
    assert json_str.contains("\"status\"");
    assert json_str.contains("201");
    assert json_str.contains("Created");
}

test "deserialize worker response from json" {
    let json_str = "{\"status\":500,\"headers\":{\"Content-Type\":\"text/plain\"},\"body\":\"Error\"}";

    let resp = try! WorkerResponse.from_json(json_str);

    assert_eq resp.status, 500;
    assert_eq resp.headers.get("Content-Type"), "text/plain";
    assert_eq resp.body, "Error";
}

test "worker response roundtrip serialization" {
    let headers: <string, string> = {"Cache-Control": "no-cache"};
    let original = WorkerResponse.new(304, headers, "");

    let json_str = try! original.to_json();
    let restored = try! WorkerResponse.from_json(json_str);

    assert_eq restored.status, original.status;
    assert_eq restored.body, original.body;
    assert_eq restored.headers.get("Cache-Control"), "no-cache";
}

// ============================================
// Test structs for frozen data tests
// ============================================

struct FrozenTestConfig {
    timeout: int,
    name: string,
}

// ============================================
// frozen<T>() tests
// ============================================

test "worker context frozen data retrieval" {
    // Create frozen data
    let config = try! freeze(FrozenTestConfig { timeout: 30, name: "test" });
    let frozen_json = try! json.to_string(config);

    // Create WorkerContext with frozen data
    let ctx = WorkerContext.new(
        "/test",
        "GET",
        {:},
        {:},
        {:},
        ""
    );
    ctx.frozen_data["config"] = frozen_json;

    // Retrieve frozen data
    let retrieved = try! ctx.frozen::<FrozenTestConfig>("config");
    let value = try! retrieved.get();

    assert_eq value.timeout, 30;
    assert_eq value.name, "test";
}

test "worker context frozen missing throws" {
    let ctx = WorkerContext.new(
        "/test",
        "GET",
        {:},
        {:},
        {:},
        ""
    );

    // Should throw when trying to get non-existent frozen data
    let threw = false;
    if (let _ = try? ctx.frozen::<int>("missing")) {
        // Should not succeed
    } else {
        threw = true;
    }
    assert threw;
}

test "worker context frozen roundtrip through json" {
    // Create frozen data
    let config = try! freeze(FrozenTestConfig { timeout: 60, name: "roundtrip" });
    let frozen_json = try! json.to_string(config);

    // Create WorkerContext with frozen data
    let original_ctx = WorkerContext.new(
        "/test",
        "GET",
        {:},
        {:},
        {:},
        ""
    );
    original_ctx.frozen_data["config"] = frozen_json;

    // Serialize and deserialize WorkerContext (simulating cross-thread transfer)
    let ctx_json = try! original_ctx.to_json();
    let restored_ctx = try! WorkerContext.from_json(ctx_json);

    // Retrieve frozen data from restored context
    let retrieved = try! restored_ctx.frozen::<FrozenTestConfig>("config");
    let value = try! retrieved.get();

    assert_eq value.timeout, 60;
    assert_eq value.name, "roundtrip";
}

test "worker context multiple frozen values" {
    let num = try! freeze(42);
    let text = try! freeze("hello world");

    let ctx = WorkerContext.new("/test", "GET", {:}, {:}, {:}, "");
    ctx.frozen_data["number"] = try! json.to_string(num);
    ctx.frozen_data["text"] = try! json.to_string(text);

    let num_frozen = try! ctx.frozen::<int>("number");
    let text_frozen = try! ctx.frozen::<string>("text");

    assert_eq try! num_frozen.get(), 42;
    assert_eq try! text_frozen.get(), "hello world";
}
