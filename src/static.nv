/// Static File Serving
///
/// Utilities for serving static files and directories.

use std.io;
use std.fs;
use std.path;

use context.Context;

/// MIME type mapping
pub struct MimeTypes {
    types: <string, string>,
}

impl MimeTypes {
    /// Create default MIME type mapping
    pub fn default(): MimeTypes {
        let types: <string, string> = {
            "html": "text/html; charset=utf-8",
            "htm": "text/html; charset=utf-8",
            "css": "text/css; charset=utf-8",
            "js": "application/javascript; charset=utf-8",
            "json": "application/json; charset=utf-8",
            "xml": "application/xml; charset=utf-8",
            "txt": "text/plain; charset=utf-8",
            "md": "text/markdown; charset=utf-8",

            // Images
            "png": "image/png",
            "jpg": "image/jpeg",
            "jpeg": "image/jpeg",
            "gif": "image/gif",
            "svg": "image/svg+xml",
            "ico": "image/x-icon",
            "webp": "image/webp",

            // Fonts
            "woff": "font/woff",
            "woff2": "font/woff2",
            "ttf": "font/ttf",
            "otf": "font/otf",
            "eot": "application/vnd.ms-fontobject",

            // Archives
            "zip": "application/zip",
            "tar": "application/x-tar",
            "gz": "application/gzip",

            // Documents
            "pdf": "application/pdf",
            "doc": "application/msword",
            "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",

            // Media
            "mp3": "audio/mpeg",
            "mp4": "video/mp4",
            "webm": "video/webm",
            "ogg": "audio/ogg",
            "wav": "audio/wav",
        };

        return MimeTypes { types };
    }

    /// Get MIME type for file extension
    pub fn get(self, ext: string): string {
        let lower_ext = ext.to_lowercase();
        return self.types.get(lower_ext) || "application/octet-stream";
    }

    /// Get MIME type from file path
    pub fn from_path(self, file_path: string): string {
        // Find last dot
        let dot_idx = file_path.rfind(".");
        if (dot_idx == nil) {
            return "application/octet-stream";
        }

        let ext = file_path.substring(dot_idx! + 1, file_path.len());
        return self.get(ext);
    }
}

/// Static file serving options
pub struct StaticOptions {
    /// Whether to list directory contents
    list_directory: bool = false,

    /// Whether to add cache headers
    cache: bool = true,

    /// Cache duration in seconds
    cache_max_age: int = 3600,

    /// Index files to serve for directories
    index_files: [string],
}

impl StaticOptions {
    /// Create default options
    pub fn default(): StaticOptions {
        return StaticOptions {
            list_directory: false,
            cache: true,
            cache_max_age: 3600,
            index_files: ["index.html", "index.htm"],
        };
    }

    /// Enable directory listing
    pub fn with_directory_listing(self, enabled: bool): StaticOptions {
        self.list_directory = enabled;
        return self;
    }

    /// Set cache options
    pub fn with_cache(self, enabled: bool, max_age: int): StaticOptions {
        self.cache = enabled;
        self.cache_max_age = max_age;
        return self;
    }

    /// Set index files
    pub fn with_index_files(self, files: [string]): StaticOptions {
        self.index_files = files;
        return self;
    }
}

/// Static file handler
pub struct StaticHandler {
    /// Root directory to serve files from
    root: string,

    /// URL prefix to strip
    url_prefix: string,

    /// Serving options
    options: StaticOptions,

    /// MIME type mapper
    mime_types: MimeTypes,
}

impl StaticHandler {
    /// Create a new static file handler
    ///
    /// # Arguments
    /// * `root` - Root directory path
    /// * `url_prefix` - URL prefix to strip (e.g., "/static")
    ///
    /// # Example
    /// ```nv
    /// let handler = StaticHandler.new("./public", "/static");
    /// ```
    pub fn new(root: string, url_prefix: string): StaticHandler {
        return StaticHandler {
            root,
            url_prefix,
            options: StaticOptions.default(),
            mime_types: MimeTypes.default(),
        };
    }

    /// Set serving options
    pub fn with_options(self, options: StaticOptions): StaticHandler {
        self.options = options;
        return self;
    }

    /// Serve a file or directory
    pub fn serve(self, ctx: Context) {
        // Get request path and strip prefix
        let request_path = ctx.path();
        let file_path = self.resolve_path(request_path);

        if (file_path == nil) {
            ctx.abort_with_status(404);
            ctx.string("Not Found");
            return;
        }

        let resolved = file_path!;

        // Check if path exists
        if (!self.path_exists(resolved)) {
            ctx.abort_with_status(404);
            ctx.string("Not Found");
            return;
        }

        // Check if it's a directory
        if (self.is_directory(resolved)) {
            self.serve_directory(ctx, resolved);
        } else {
            self.serve_file(ctx, resolved);
        }
    }

    /// Resolve request path to file system path
    fn resolve_path(self, request_path: string): string? {
        // Strip URL prefix
        let path = request_path;
        if (self.url_prefix.len() > 0 && path.starts_with(self.url_prefix)) {
            path = path.substring(self.url_prefix.len(), path.len());
        }

        // Remove leading slash
        if (path.starts_with("/")) {
            path = path.substring(1, path.len());
        }

        // Security: prevent directory traversal
        if (path.contains("..")) {
            return nil;
        }

        // Combine with root
        if (path.len() == 0) {
            return self.root;
        }

        return self.root + "/" + path;
    }

    /// Check if path exists
    fn path_exists(self, path: string): bool {
        // TODO: Use proper fs API when available
        // For now, try to read the file
        return try? fs.read_file(path) != nil;
    }

    /// Check if path is a directory
    fn is_directory(self, path: string): bool {
        // TODO: Use proper fs API when available
        // For now, check if it ends with / or doesn't have extension
        return path.ends_with("/") || !path.contains(".");
    }

    /// Serve a directory
    fn serve_directory(self, ctx: Context, dir_path: string) {
        // Try to serve index file
        for (let index_file in self.options.index_files) {
            let index_path = dir_path + "/" + index_file;
            if (self.path_exists(index_path)) {
                self.serve_file(ctx, index_path);
                return;
            }
        }

        // Directory listing
        if (self.options.list_directory) {
            self.serve_directory_listing(ctx, dir_path);
        } else {
            ctx.abort_with_status(403);
            ctx.string("Forbidden");
        }
    }

    /// Serve directory listing
    fn serve_directory_listing(self, ctx: Context, dir_path: string) {
        // TODO: Implement proper directory listing when fs API is available
        ctx.html(`
            <!DOCTYPE html>
            <html>
            <head>
                <title>Directory Listing</title>
                <style>
                    body { font-family: monospace; margin: 2em; }
                    a { display: block; padding: 0.5em 0; }
                </style>
            </head>
            <body>
                <h1>Directory: ${dir_path}</h1>
                <p>Directory listing not fully implemented yet.</p>
            </body>
            </html>
        `);
    }

    /// Serve a single file
    fn serve_file(self, ctx: Context, file_path: string) {
        // Read file content
        let content = try? fs.read_file(file_path);
        if (content == nil) {
            ctx.abort_with_status(500);
            ctx.string("Internal Server Error");
            return;
        }

        // Set MIME type
        let mime_type = self.mime_types.from_path(file_path);
        ctx.set_header("Content-Type", mime_type);

        // Set cache headers
        if (self.options.cache) {
            ctx.set_header("Cache-Control", `public, max-age=${self.options.cache_max_age}`);
        }

        // Send file content
        ctx.response.write(content!);
    }
}

/// Create a handler for serving a single file
///
/// # Example
/// ```nv
/// app.get("/favicon.ico", serve_file("./public/favicon.ico"));
/// ```
pub fn serve_file(file_path: string): HandlerFunc {
    return |ctx: Context| {
        let content = try? fs.read_file(file_path);
        if (content == nil) {
            ctx.abort_with_status(404);
            ctx.string("Not Found");
            return;
        }

        let mime_types = MimeTypes.default();
        let mime_type = mime_types.from_path(file_path);
        ctx.set_header("Content-Type", mime_type);
        ctx.response.write(content!);
    };
}

// ============================================
// Tests
// ============================================

test "mime types" {
    let mime = MimeTypes.default();

    assert_eq mime.get("html"), "text/html; charset=utf-8";
    assert_eq mime.get("js"), "application/javascript; charset=utf-8";
    assert_eq mime.get("png"), "image/png";
    assert_eq mime.get("unknown"), "application/octet-stream";
}

test "mime from path" {
    let mime = MimeTypes.default();

    assert_eq mime.from_path("index.html"), "text/html; charset=utf-8";
    assert_eq mime.from_path("/assets/style.css"), "text/css; charset=utf-8";
    assert_eq mime.from_path("app.js"), "application/javascript; charset=utf-8";
    assert_eq mime.from_path("image.png"), "image/png";
}

test "static options" {
    let opts = StaticOptions.default();

    assert_eq opts.list_directory, false;
    assert_eq opts.cache, true;
    assert_eq opts.cache_max_age, 3600;
    assert_eq opts.index_files.len(), 2;
}

test "resolve path" {
    let handler = StaticHandler.new("./public", "/static");

    let path1 = handler.resolve_path("/static/css/style.css");
    assert path1 != nil;
    assert_eq path1!, "./public/css/style.css";

    let path2 = handler.resolve_path("/static/");
    assert path2 != nil;
    assert_eq path2!, "./public";
}

test "prevent directory traversal" {
    let handler = StaticHandler.new("./public", "/static");

    let bad_path = handler.resolve_path("/static/../../../etc/passwd");
    assert_eq bad_path, nil;
}
