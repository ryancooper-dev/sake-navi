/// HTTP Router
///
/// Handles route registration and matching for HTTP requests.
/// Supports path parameters (:id) and wildcard (*path) routes.
///
/// # Example
/// ```nv
/// let router = Router.new();
///
/// router.add("GET", "/users", handler);
/// router.add("GET", "/users/:id", user_handler);
/// router.add("GET", "/static/*path", static_handler);
///
/// let route = router.match("GET", "/users/123");
/// ```

use context.{Context, HandlerFunc};

/// Route definition
pub struct Route {
    /// HTTP method (GET, POST, etc.)
    method: string,

    /// Path pattern (/users/:id)
    pattern: string,

    /// Handler function
    handler: HandlerFunc,

    /// Whether this route uses WorkerPool
    use_worker_pool: bool = false,

    /// Middleware for this specific route
    middleware: [HandlerFunc],
}

impl Route {
    /// Mark this route to use WorkerPool for CPU-intensive tasks
    ///
    /// # Example
    /// ```nv
    /// router.add("GET", "/compute", handler).worker();
    /// ```
    pub fn worker(self): Route {
        self.use_worker_pool = true;
        return self;
    }

    /// Add middleware to this specific route
    pub fn use(self, middleware: HandlerFunc): Route {
        self.middleware.push(middleware);
        return self;
    }
}

/// Matched route with extracted parameters
pub struct RouteMatch {
    /// The matched route
    route: Route,

    /// Extracted path parameters
    params: <string, string>,
}

/// HTTP Router
pub struct Router {
    /// Registered routes
    routes: [Route],

    /// Global middleware
    middleware: [HandlerFunc],
}

/// Router Group for organizing routes with common prefix and middleware
pub struct RouterGroup {
    /// Path prefix for this group
    prefix: string,

    /// Reference to the parent router
    router: Router,

    /// Middleware specific to this group
    middleware: [HandlerFunc],
}

impl Router {
    /// Create a new Router
    pub fn new(): Router {
        return Router {
            routes: [],
            middleware: [],
        };
    }

    /// Add a route
    ///
    /// # Arguments
    /// * `method` - HTTP method (GET, POST, PUT, DELETE, etc.)
    /// * `pattern` - Path pattern (/users/:id)
    /// * `handler` - Handler function
    ///
    /// # Returns
    /// The created Route (for chaining .worker() or .use())
    pub fn add(self, method: string, pattern: string, handler: HandlerFunc): Route {
        let route = Route {
            method: method.to_uppercase(),
            pattern,
            handler,
            middleware: [],
        };

        self.routes.push(route);
        return route;
    }

    /// Add GET route
    pub fn get(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("GET", pattern, handler);
    }

    /// Add POST route
    pub fn post(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("POST", pattern, handler);
    }

    /// Add PUT route
    pub fn put(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("PUT", pattern, handler);
    }

    /// Add DELETE route
    pub fn delete(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("DELETE", pattern, handler);
    }

    /// Add PATCH route
    pub fn patch(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("PATCH", pattern, handler);
    }

    /// Add HEAD route
    pub fn head(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("HEAD", pattern, handler);
    }

    /// Add OPTIONS route
    pub fn options(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("OPTIONS", pattern, handler);
    }

    /// Add route for any HTTP method
    ///
    /// # Arguments
    /// * `pattern` - Path pattern
    /// * `handler` - Handler function
    ///
    /// # Returns
    /// Array of created routes for all methods
    ///
    /// # Example
    /// ```nv
    /// router.any("/resource", |ctx| {
    ///     ctx.json({"message": "Any method accepted"});
    /// });
    /// ```
    pub fn any(self, pattern: string, handler: HandlerFunc) {
        let methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"];
        for (let method in methods) {
            self.add(method, pattern, handler);
        }
    }

    /// Add route with custom HTTP method
    ///
    /// # Arguments
    /// * `method` - HTTP method (can be non-standard like "PROPFIND")
    /// * `pattern` - Path pattern
    /// * `handler` - Handler function
    ///
    /// # Returns
    /// The created Route
    ///
    /// # Example
    /// ```nv
    /// router.handle("PROPFIND", "/webdav", propfind_handler);
    /// ```
    pub fn handle(self, method: string, pattern: string, handler: HandlerFunc): Route {
        return self.add(method, pattern, handler);
    }

    /// Add global middleware
    ///
    /// # Arguments
    /// * `middleware` - Middleware handler
    pub fn use(self, middleware: HandlerFunc) {
        self.middleware.push(middleware);
    }

    /// Match a request to a route
    ///
    /// # Arguments
    /// * `method` - HTTP method
    /// * `path` - Request path
    ///
    /// # Returns
    /// RouteMatch if found, nil otherwise
    pub fn match(self, method: string, path: string): RouteMatch? {
        let upper_method = method.to_uppercase();

        for (let route in self.routes) {
            if (route.method != upper_method) {
                continue;
            }

            let params = self.match_pattern(route.pattern, path);
            if (params != nil) {
                return RouteMatch {
                    route,
                    params: params!,
                };
            }
        }

        return nil;
    }

    /// Match a path pattern against a request path
    ///
    /// # Arguments
    /// * `pattern` - Route pattern (/users/:id)
    /// * `path` - Request path (/users/123)
    ///
    /// # Returns
    /// Map of parameters if match, nil otherwise
    fn match_pattern(self, pattern: string, path: string): <string, string>? {
        let params: <string, string> = {:};

        // Simple exact match
        if (pattern == path) {
            return params;
        }

        // Split into segments
        let pattern_parts = pattern.split("/");
        let path_parts = path.split("/");

        // Must have same number of segments (unless wildcard)
        if (pattern_parts.len() != path_parts.len()) {
            // Check for wildcard
            if (pattern.contains("*")) {
                return self.match_wildcard(pattern, path);
            }
            return nil;
        }

        // Match each segment
        for (let i in 0..pattern_parts.len()) {
            let pattern_part = pattern_parts[i];
            let path_part = path_parts[i];

            // Parameter segment (:id)
            if (pattern_part.starts_with(":")) {
                let param_name = pattern_part.substring(1, pattern_part.len());
                params[param_name] = path_part;
                continue;
            }

            // Exact match required
            if (pattern_part != path_part) {
                return nil;
            }
        }

        return params;
    }

    /// Match wildcard patterns
    fn match_wildcard(self, pattern: string, path: string): <string, string>? {
        let params: <string, string> = {:};

        // Find wildcard position
        let wildcard_idx = pattern.find("*");
        if (wildcard_idx == nil) {
            return nil;
        }

        let idx = wildcard_idx!;

        // Extract prefix
        let prefix = if (idx > 0) {
            pattern.substring(0, idx)
        } else {
            ""
        };

        // Path must start with prefix
        if (prefix.len() > 0 && !path.starts_with(prefix)) {
            return nil;
        }

        // Extract wildcard name
        let wildcard_part = pattern.substring(idx, pattern.len());
        let wildcard_name = if (wildcard_part.starts_with("*")) {
            wildcard_part.substring(1, wildcard_part.len())
        } else {
            "path"
        };

        // Capture remaining path
        let captured = path.substring(prefix.len(), path.len());
        params[wildcard_name] = captured;

        return params;
    }

    /// Get all handlers for a matched route (global middleware + route middleware + handler)
    pub fn get_handlers(self, route_match: RouteMatch): [HandlerFunc] {
        let handlers: [HandlerFunc] = [];

        // Add global middleware
        for (let mw in self.middleware) {
            handlers.push(mw);
        }

        // Add route-specific middleware
        for (let mw in route_match.route.middleware) {
            handlers.push(mw);
        }

        // Add final handler
        handlers.push(route_match.route.handler);

        return handlers;
    }

    /// Create a new router group with the given prefix
    ///
    /// # Arguments
    /// * `prefix` - URL path prefix (e.g., "/api", "/v1")
    ///
    /// # Returns
    /// RouterGroup for method chaining
    ///
    /// # Example
    /// ```nv
    /// let api = router.group("/api");
    /// api.get("/users", handler);  // Matches /api/users
    /// ```
    pub fn group(self, prefix: string): RouterGroup {
        return RouterGroup {
            prefix,
            router: self,
            middleware: [],
        };
    }
}

impl RouterGroup {
    /// Combine group prefix with pattern
    fn full_path(self, pattern: string): string {
        // Handle edge cases
        if (self.prefix == "" || self.prefix == "/") {
            return pattern;
        }

        // Remove trailing slash from prefix
        let prefix = self.prefix;
        if (prefix.ends_with("/")) {
            prefix = prefix.substring(0, prefix.len() - 1);
        }

        // Ensure pattern starts with /
        let path = pattern;
        if (!path.starts_with("/")) {
            path = "/" + path;
        }

        return prefix + path;
    }

    /// Add route with group middleware
    fn add_route(self, method: string, pattern: string, handler: HandlerFunc): Route {
        let full_pattern = self.full_path(pattern);
        let route = self.router.add(method, full_pattern, handler);

        // Add group middleware to the route
        for (let mw in self.middleware) {
            route.middleware.push(mw);
        }

        return route;
    }

    /// Add GET route to this group
    pub fn get(self, pattern: string, handler: HandlerFunc): Route {
        return self.add_route("GET", pattern, handler);
    }

    /// Add POST route to this group
    pub fn post(self, pattern: string, handler: HandlerFunc): Route {
        return self.add_route("POST", pattern, handler);
    }

    /// Add PUT route to this group
    pub fn put(self, pattern: string, handler: HandlerFunc): Route {
        return self.add_route("PUT", pattern, handler);
    }

    /// Add DELETE route to this group
    pub fn delete(self, pattern: string, handler: HandlerFunc): Route {
        return self.add_route("DELETE", pattern, handler);
    }

    /// Add PATCH route to this group
    pub fn patch(self, pattern: string, handler: HandlerFunc): Route {
        return self.add_route("PATCH", pattern, handler);
    }

    /// Add HEAD route to this group
    pub fn head(self, pattern: string, handler: HandlerFunc): Route {
        return self.add_route("HEAD", pattern, handler);
    }

    /// Add OPTIONS route to this group
    pub fn options(self, pattern: string, handler: HandlerFunc): Route {
        return self.add_route("OPTIONS", pattern, handler);
    }

    /// Add route for any HTTP method to this group
    pub fn any(self, pattern: string, handler: HandlerFunc) {
        let methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"];
        for (let method in methods) {
            self.add_route(method, pattern, handler);
        }
    }

    /// Add route with custom HTTP method to this group
    pub fn handle(self, method: string, pattern: string, handler: HandlerFunc): Route {
        return self.add_route(method, pattern, handler);
    }

    /// Add middleware to this group
    ///
    /// # Arguments
    /// * `middleware` - Middleware handler
    ///
    /// # Returns
    /// Self for chaining
    ///
    /// # Example
    /// ```nv
    /// let api = router.group("/api");
    /// api.use(auth_middleware);
    /// api.get("/users", handler);
    /// ```
    pub fn use(self, middleware: HandlerFunc): RouterGroup {
        self.middleware.push(middleware);
        return self;
    }

    /// Create a nested group with combined prefix
    ///
    /// # Arguments
    /// * `prefix` - Additional prefix for nested group
    ///
    /// # Returns
    /// New RouterGroup with combined prefix
    ///
    /// # Example
    /// ```nv
    /// let api = router.group("/api");
    /// let v1 = api.group("/v1");  // Full prefix: /api/v1
    /// v1.get("/users", handler);   // Matches /api/v1/users
    /// ```
    pub fn group(self, prefix: string): RouterGroup {
        let combined_prefix = self.full_path(prefix);
        return RouterGroup {
            prefix: combined_prefix,
            router: self.router,
            middleware: self.middleware.clone(),  // Inherit parent middleware
        };
    }
}

// ============================================
// Tests
// ============================================

test "create router" {
    let router = Router.new();
    assert_eq router.routes.len(), 0;
}

test "add routes" {
    let router = Router.new();

    router.get("/", |ctx| {
        ctx.string("home");
    });

    router.post("/users", |ctx| {
        ctx.string("create user");
    });

    assert_eq router.routes.len(), 2;
    assert_eq router.routes[0].method, "GET";
    assert_eq router.routes[1].method, "POST";
}

test "match exact path" {
    let router = Router.new();

    router.get("/users", |ctx| {
        ctx.string("users");
    });

    let result = router.match("GET", "/users");
    assert result != nil;

    let no_match = router.match("GET", "/posts");
    assert_eq no_match, nil;
}

test "match with parameters" {
    let router = Router.new();

    router.get("/users/:id", |ctx| {
        ctx.string("user");
    });

    let result = router.match("GET", "/users/123");
    assert result != nil;

    let params = result!.params;
    assert_eq params.get("id"), "123";
}

test "match wildcard" {
    let router = Router.new();

    router.get("/static/*filepath", |ctx| {
        ctx.string("static");
    });

    let result = router.match("GET", "/static/css/style.css");
    assert result != nil;

    let params = result!.params;
    assert_eq params.get("filepath"), "css/style.css";
}

test "route uses worker pool" {
    let router = Router.new();

    router.get("/compute", |ctx| {
        ctx.string("computing");
    }).worker();

    let result = router.match("GET", "/compute");
    assert result != nil;
    assert_eq result!.route.use_worker_pool, true;
}

test "route specific middleware" {
    let router = Router.new();

    let auth_middleware = |ctx: Context| {
        ctx.set("auth", true);
        try ctx.next();
    };

    router.get("/protected", |ctx| {
        ctx.string("protected");
    }).use(auth_middleware);

    let result = router.match("GET", "/protected");
    assert result != nil;
    assert_eq result!.route.middleware.len(), 1;
}

test "method matching" {
    let router = Router.new();

    router.get("/resource", |ctx| { ctx.string("get"); });
    router.post("/resource", |ctx| { ctx.string("post"); });

    let get_match = router.match("GET", "/resource");
    assert get_match != nil;
    assert_eq get_match!.route.method, "GET";

    let post_match = router.match("POST", "/resource");
    assert post_match != nil;
    assert_eq post_match!.route.method, "POST";

    let put_match = router.match("PUT", "/resource");
    assert_eq put_match, nil;
}

test "head and options routes" {
    let router = Router.new();

    router.head("/resource", |ctx| { ctx.status(200); });
    router.options("/resource", |ctx| { ctx.string("OPTIONS"); });

    let head_match = router.match("HEAD", "/resource");
    assert head_match != nil;
    assert_eq head_match!.route.method, "HEAD";

    let options_match = router.match("OPTIONS", "/resource");
    assert options_match != nil;
    assert_eq options_match!.route.method, "OPTIONS";
}

test "any method route" {
    let router = Router.new();

    router.any("/resource", |ctx| { ctx.string("any"); });

    // Should match all standard methods
    let get_match = router.match("GET", "/resource");
    assert get_match != nil;

    let post_match = router.match("POST", "/resource");
    assert post_match != nil;

    let put_match = router.match("PUT", "/resource");
    assert put_match != nil;

    let delete_match = router.match("DELETE", "/resource");
    assert delete_match != nil;

    let patch_match = router.match("PATCH", "/resource");
    assert patch_match != nil;

    let head_match = router.match("HEAD", "/resource");
    assert head_match != nil;

    let options_match = router.match("OPTIONS", "/resource");
    assert options_match != nil;
}

test "custom method with handle" {
    let router = Router.new();

    router.handle("PROPFIND", "/webdav", |ctx| { ctx.string("webdav"); });

    let match_result = router.match("PROPFIND", "/webdav");
    assert match_result != nil;
    assert_eq match_result!.route.method, "PROPFIND";
}

test "router group basic" {
    let router = Router.new();
    let api = router.group("/api");

    api.get("/users", |ctx| { ctx.string("users"); });

    let match_result = router.match("GET", "/api/users");
    assert match_result != nil;
    assert_eq match_result!.route.pattern, "/api/users";
}

test "router group with multiple routes" {
    let router = Router.new();
    let api = router.group("/api");

    api.get("/users", |ctx| { ctx.string("get users"); });
    api.post("/users", |ctx| { ctx.string("create user"); });
    api.put("/users/:id", |ctx| { ctx.string("update user"); });

    let get_match = router.match("GET", "/api/users");
    assert get_match != nil;

    let post_match = router.match("POST", "/api/users");
    assert post_match != nil;

    let put_match = router.match("PUT", "/api/users/123");
    assert put_match != nil;
    assert_eq put_match!.params.get("id"), "123";
}

test "nested router groups" {
    let router = Router.new();
    let api = router.group("/api");
    let v1 = api.group("/v1");

    v1.get("/users", |ctx| { ctx.string("v1 users"); });

    let match_result = router.match("GET", "/api/v1/users");
    assert match_result != nil;
    assert_eq match_result!.route.pattern, "/api/v1/users";
}

test "router group middleware" {
    let router = Router.new();

    let auth_middleware = |ctx: Context| {
        ctx.set("auth", true);
        try ctx.next();
    };

    let api = router.group("/api");
    api.use(auth_middleware);
    api.get("/users", |ctx| { ctx.string("users"); });

    let match_result = router.match("GET", "/api/users");
    assert match_result != nil;
    assert_eq match_result!.route.middleware.len(), 1;
}

test "nested groups inherit middleware" {
    let router = Router.new();

    let logger = |ctx: Context| {
        println("log");
        try ctx.next();
    };

    let auth = |ctx: Context| {
        println("auth");
        try ctx.next();
    };

    let api = router.group("/api");
    api.use(logger);

    let v1 = api.group("/v1");
    v1.use(auth);
    v1.get("/users", |ctx| { ctx.string("users"); });

    let match_result = router.match("GET", "/api/v1/users");
    assert match_result != nil;
    // Should have both logger and auth middleware
    assert_eq match_result!.route.middleware.len(), 2;
}

test "router group with any method" {
    let router = Router.new();
    let api = router.group("/api");

    api.any("/resource", |ctx| { ctx.string("any method"); });

    let get_match = router.match("GET", "/api/resource");
    assert get_match != nil;

    let post_match = router.match("POST", "/api/resource");
    assert post_match != nil;

    let delete_match = router.match("DELETE", "/api/resource");
    assert delete_match != nil;
}

test "router group handles trailing slashes" {
    let router = Router.new();
    let api = router.group("/api/");  // Trailing slash in prefix

    api.get("/users", |ctx| { ctx.string("users"); });

    let match_result = router.match("GET", "/api/users");
    assert match_result != nil;
    assert_eq match_result!.route.pattern, "/api/users";
}
