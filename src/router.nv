/// HTTP Router
///
/// Handles route registration and matching for HTTP requests.
/// Supports path parameters (:id) and wildcard (*path) routes.
///
/// # Example
/// ```nv
/// let router = Router.new();
///
/// router.add("GET", "/users", handler);
/// router.add("GET", "/users/:id", user_handler);
/// router.add("GET", "/static/*path", static_handler);
///
/// let route = router.match("GET", "/users/123");
/// ```

use context.{Context, HandlerFunc};

/// Route definition
pub struct Route {
    /// HTTP method (GET, POST, etc.)
    method: string,

    /// Path pattern (/users/:id)
    pattern: string,

    /// Handler function
    handler: HandlerFunc,

    /// Whether this route uses WorkerPool
    use_worker_pool: bool = false,

    /// Middleware for this specific route
    middleware: [HandlerFunc],
}

impl Route {
    /// Mark this route to use WorkerPool for CPU-intensive tasks
    ///
    /// # Example
    /// ```nv
    /// router.add("GET", "/compute", handler).worker();
    /// ```
    pub fn worker(self): Route {
        self.use_worker_pool = true;
        return self;
    }

    /// Add middleware to this specific route
    pub fn use(self, middleware: HandlerFunc): Route {
        self.middleware.push(middleware);
        return self;
    }
}

/// Matched route with extracted parameters
pub struct RouteMatch {
    /// The matched route
    route: Route,

    /// Extracted path parameters
    params: <string, string>,
}

/// HTTP Router
pub struct Router {
    /// Registered routes
    routes: [Route],

    /// Global middleware
    middleware: [HandlerFunc],
}

impl Router {
    /// Create a new Router
    pub fn new(): Router {
        return Router {
            routes: [],
            middleware: [],
        };
    }

    /// Add a route
    ///
    /// # Arguments
    /// * `method` - HTTP method (GET, POST, PUT, DELETE, etc.)
    /// * `pattern` - Path pattern (/users/:id)
    /// * `handler` - Handler function
    ///
    /// # Returns
    /// The created Route (for chaining .worker() or .use())
    pub fn add(self, method: string, pattern: string, handler: HandlerFunc): Route {
        let route = Route {
            method: method.to_uppercase(),
            pattern,
            handler,
            middleware: [],
        };

        self.routes.push(route);
        return route;
    }

    /// Add GET route
    pub fn get(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("GET", pattern, handler);
    }

    /// Add POST route
    pub fn post(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("POST", pattern, handler);
    }

    /// Add PUT route
    pub fn put(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("PUT", pattern, handler);
    }

    /// Add DELETE route
    pub fn delete(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("DELETE", pattern, handler);
    }

    /// Add PATCH route
    pub fn patch(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("PATCH", pattern, handler);
    }

    /// Add HEAD route
    pub fn head(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("HEAD", pattern, handler);
    }

    /// Add OPTIONS route
    pub fn options(self, pattern: string, handler: HandlerFunc): Route {
        return self.add("OPTIONS", pattern, handler);
    }

    /// Add route for any HTTP method
    ///
    /// # Arguments
    /// * `pattern` - Path pattern
    /// * `handler` - Handler function
    ///
    /// # Returns
    /// Array of created routes for all methods
    ///
    /// # Example
    /// ```nv
    /// router.any("/resource", |ctx| {
    ///     ctx.json({"message": "Any method accepted"});
    /// });
    /// ```
    pub fn any(self, pattern: string, handler: HandlerFunc) {
        let methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"];
        for (let method in methods) {
            self.add(method, pattern, handler);
        }
    }

    /// Add route with custom HTTP method
    ///
    /// # Arguments
    /// * `method` - HTTP method (can be non-standard like "PROPFIND")
    /// * `pattern` - Path pattern
    /// * `handler` - Handler function
    ///
    /// # Returns
    /// The created Route
    ///
    /// # Example
    /// ```nv
    /// router.handle("PROPFIND", "/webdav", propfind_handler);
    /// ```
    pub fn handle(self, method: string, pattern: string, handler: HandlerFunc): Route {
        return self.add(method, pattern, handler);
    }

    /// Add global middleware
    ///
    /// # Arguments
    /// * `middleware` - Middleware handler
    pub fn use(self, middleware: HandlerFunc) {
        self.middleware.push(middleware);
    }

    /// Match a request to a route
    ///
    /// # Arguments
    /// * `method` - HTTP method
    /// * `path` - Request path
    ///
    /// # Returns
    /// RouteMatch if found, nil otherwise
    pub fn match(self, method: string, path: string): RouteMatch? {
        let upper_method = method.to_uppercase();

        for (let route in self.routes) {
            if (route.method != upper_method) {
                continue;
            }

            let params = self.match_pattern(route.pattern, path);
            if (params != nil) {
                return RouteMatch {
                    route,
                    params: params!,
                };
            }
        }

        return nil;
    }

    /// Match a path pattern against a request path
    ///
    /// # Arguments
    /// * `pattern` - Route pattern (/users/:id)
    /// * `path` - Request path (/users/123)
    ///
    /// # Returns
    /// Map of parameters if match, nil otherwise
    fn match_pattern(self, pattern: string, path: string): <string, string>? {
        let params: <string, string> = {:};

        // Simple exact match
        if (pattern == path) {
            return params;
        }

        // Split into segments
        let pattern_parts = pattern.split("/");
        let path_parts = path.split("/");

        // Must have same number of segments (unless wildcard)
        if (pattern_parts.len() != path_parts.len()) {
            // Check for wildcard
            if (pattern.contains("*")) {
                return self.match_wildcard(pattern, path);
            }
            return nil;
        }

        // Match each segment
        for (let i in 0..pattern_parts.len()) {
            let pattern_part = pattern_parts[i];
            let path_part = path_parts[i];

            // Parameter segment (:id)
            if (pattern_part.starts_with(":")) {
                let param_name = pattern_part.substring(1, pattern_part.len());
                params[param_name] = path_part;
                continue;
            }

            // Exact match required
            if (pattern_part != path_part) {
                return nil;
            }
        }

        return params;
    }

    /// Match wildcard patterns
    fn match_wildcard(self, pattern: string, path: string): <string, string>? {
        let params: <string, string> = {:};

        // Find wildcard position
        let wildcard_idx = pattern.find("*");
        if (wildcard_idx == nil) {
            return nil;
        }

        let idx = wildcard_idx!;

        // Extract prefix
        let prefix = if (idx > 0) {
            pattern.substring(0, idx)
        } else {
            ""
        };

        // Path must start with prefix
        if (prefix.len() > 0 && !path.starts_with(prefix)) {
            return nil;
        }

        // Extract wildcard name
        let wildcard_part = pattern.substring(idx, pattern.len());
        let wildcard_name = if (wildcard_part.starts_with("*")) {
            wildcard_part.substring(1, wildcard_part.len())
        } else {
            "path"
        };

        // Capture remaining path
        let captured = path.substring(prefix.len(), path.len());
        params[wildcard_name] = captured;

        return params;
    }

    /// Get all handlers for a matched route (global middleware + route middleware + handler)
    pub fn get_handlers(self, route_match: RouteMatch): [HandlerFunc] {
        let handlers: [HandlerFunc] = [];

        // Add global middleware
        for (let mw in self.middleware) {
            handlers.push(mw);
        }

        // Add route-specific middleware
        for (let mw in route_match.route.middleware) {
            handlers.push(mw);
        }

        // Add final handler
        handlers.push(route_match.route.handler);

        return handlers;
    }
}

// ============================================
// Tests
// ============================================

test "create router" {
    let router = Router.new();
    assert_eq router.routes.len(), 0;
}

test "add routes" {
    let router = Router.new();

    router.get("/", |ctx| {
        ctx.string("home");
    });

    router.post("/users", |ctx| {
        ctx.string("create user");
    });

    assert_eq router.routes.len(), 2;
    assert_eq router.routes[0].method, "GET";
    assert_eq router.routes[1].method, "POST";
}

test "match exact path" {
    let router = Router.new();

    router.get("/users", |ctx| {
        ctx.string("users");
    });

    let result = router.match("GET", "/users");
    assert result != nil;

    let no_match = router.match("GET", "/posts");
    assert_eq no_match, nil;
}

test "match with parameters" {
    let router = Router.new();

    router.get("/users/:id", |ctx| {
        ctx.string("user");
    });

    let result = router.match("GET", "/users/123");
    assert result != nil;

    let params = result!.params;
    assert_eq params.get("id"), "123";
}

test "match wildcard" {
    let router = Router.new();

    router.get("/static/*filepath", |ctx| {
        ctx.string("static");
    });

    let result = router.match("GET", "/static/css/style.css");
    assert result != nil;

    let params = result!.params;
    assert_eq params.get("filepath"), "css/style.css";
}

test "route uses worker pool" {
    let router = Router.new();

    router.get("/compute", |ctx| {
        ctx.string("computing");
    }).worker();

    let result = router.match("GET", "/compute");
    assert result != nil;
    assert_eq result!.route.use_worker_pool, true;
}

test "route specific middleware" {
    let router = Router.new();

    let auth_middleware = |ctx: Context| {
        ctx.set("auth", true);
        try ctx.next();
    };

    router.get("/protected", |ctx| {
        ctx.string("protected");
    }).use(auth_middleware);

    let result = router.match("GET", "/protected");
    assert result != nil;
    assert_eq result!.route.middleware.len(), 1;
}

test "method matching" {
    let router = Router.new();

    router.get("/resource", |ctx| { ctx.string("get"); });
    router.post("/resource", |ctx| { ctx.string("post"); });

    let get_match = router.match("GET", "/resource");
    assert get_match != nil;
    assert_eq get_match!.route.method, "GET";

    let post_match = router.match("POST", "/resource");
    assert post_match != nil;
    assert_eq post_match!.route.method, "POST";

    let put_match = router.match("PUT", "/resource");
    assert_eq put_match, nil;
}

test "head and options routes" {
    let router = Router.new();

    router.head("/resource", |ctx| { ctx.status(200); });
    router.options("/resource", |ctx| { ctx.string("OPTIONS"); });

    let head_match = router.match("HEAD", "/resource");
    assert head_match != nil;
    assert_eq head_match!.route.method, "HEAD";

    let options_match = router.match("OPTIONS", "/resource");
    assert options_match != nil;
    assert_eq options_match!.route.method, "OPTIONS";
}

test "any method route" {
    let router = Router.new();

    router.any("/resource", |ctx| { ctx.string("any"); });

    // Should match all standard methods
    let get_match = router.match("GET", "/resource");
    assert get_match != nil;

    let post_match = router.match("POST", "/resource");
    assert post_match != nil;

    let put_match = router.match("PUT", "/resource");
    assert put_match != nil;

    let delete_match = router.match("DELETE", "/resource");
    assert delete_match != nil;

    let patch_match = router.match("PATCH", "/resource");
    assert patch_match != nil;

    let head_match = router.match("HEAD", "/resource");
    assert head_match != nil;

    let options_match = router.match("OPTIONS", "/resource");
    assert options_match != nil;
}

test "custom method with handle" {
    let router = Router.new();

    router.handle("PROPFIND", "/webdav", |ctx| { ctx.string("webdav"); });

    let match_result = router.match("PROPFIND", "/webdav");
    assert match_result != nil;
    assert_eq match_result!.route.method, "PROPFIND";
}
